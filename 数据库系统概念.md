# 数据库系统概念考前复习

## 引言

### 四个基本概念

**数据Data**

数据库中存储的基本对象

- 定义：描述事物的符号记录
- 种类：文字、图形、图像、声音
- 特点：数据与其语义不可分



数据结构

逻辑结构：数据之间存在的逻辑关系

物理结构：数据在计算机内的存储方式



**数据库DataBase**

长期存储在计算机内、有组织的、可共享的大量数据集合

- 数据按一定的数据模型组织、描述、存储
- 为各种用户共享
- 冗余度较小
- 数据独立性高
- 易扩展



**数据库管理系统 DBMS**

由一个相互关联的数据的集合和一组用以访问这些数据的程序组成

位于用户与操作系统之间的一层数据管理软件

主要功能:

- 数据定义功能 

提供数据库定义语言DDL,定义数据库中的数据对象

- 数据操纵功能

提供数据操作语言DML,操纵数据实现对数据库的基本操作(查询、插入、删除、修改)

- 数据库的运行管理

保证多用户对数据的并发使用；数据的安全性、完整性；保证故障后的系统恢复

- 数据库的建立和维护功能

数据库数据批量装载,数据库转储...

**数据库系统**

在计算机系统中引入数据库后的系统



构成：

- 数据库
- 数据库管理系统
- 应用系统及其开发工具
- 数据库管理员
- 用户



### 数据管理技术的发展

**数据管理**

对数据进行分类、组织、编码、存储、检索和维护

**数据管理的发展阶段**

人工管理阶段，文件系统阶段，数据库系统阶段，大数据阶段



**数据库系统阶段**

数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象

特点：

- 数据由DBMS统一存取，维护数据语义及结构
- 面向全组织，面向现实世界
- 独立性较强
- 数据统一按表结构存放



### 数据模型--数据库结构的基础

**数据模型描述**：

- 数据
- 数据关系
- 数据语义
- 数据约束



**常用数据模型**：

- `关系模型`

- `实体-联系数据模型`  主要用于数据库设计

- 半结构化数据模型 XML JSON
- 基于对象的数据模型
- 早期的数据模型
  - 网状模型
  - 层次模型



**实例和模式**

型和值的区别

型是对数据的结构和属性的说明(模式)

值是型的一个具体赋值(实例)

型是相对稳定的，值是随时间不断变化的



**数据抽象**

`模式`

数据库的总体设计

- 物理模式：在物理层描述的数据库设计
- 逻辑模式：在逻辑层描述的数据库设计
- 子模式/外模式：在视图层描述的数据库设计，逻辑模式的子集

`实例`

特定时刻存储在数据库中的信息的集合



物理数据独立性：物理模式的改变不会影响逻辑模式

当物理模式改变时，修改模式/内模式映象，使外模式不变，从而应用程序可以保持不变

逻辑数据独立性

当模式改变时，修改外模式/模式映象，使外模式保持不变，从而应用程序可以保持不变



### 数据库语言

**DDL**

Data Definition Language 用于定义数据库模式以及其他特征的语言

- 数据库模式
- 完整性约束
- 断言
- 授权

**DML**

Data  Manipulation Language 操纵那些按照某种适当的数据模型组织起来的数据的语言

- 查询
- 更新(增、删、改)

分类：过程化和声明式(非过程化)

SQL：广泛使用的非过程话语言



### 数据库设计

数据库设计的主要内容式`数据库模式的实际`

设计过程：

- 用户需求获取
- 概念设计
- 逻辑设计
- 物理设计



### 数据库引擎

**存储管理器**

是一个程序模块，提供了数据库中存储的低层数据与应用程序以及向系统提交的查询之间的接口

任务：与文件管理器交互，对数据的有效的存储、查询和更新

部件：权限及完整性管理器、事务管理器、文件管理器、缓冲区管理器

**查询处理器**

DDL解释器：它解释DDL语句，并将这些定义记录在数据字典中

DML编译器：将查询语言中的DML语句翻译成为一个执行方案

查询执行引擎：执行由DML编译器产生的低级指令

**事务管理**

事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位

事务特性：原子性、持久性、一致性、隔离性



### 数据库和应用系统结构

**数据库体系结构**

- 集中式
- 客户/服务器式
- 并行（多处理器）
- 分布式



### 数据库管理员

对数据库系统进行集中控制的人称作数据库管理员

作用：

- 模式定义
- 存储结构及存取方式定义
- 模式及物理组织的修改
- 数据访问授权
- 日常维护



## 关系模型

### 关系数据结构

关系型数据库中，关系是一种单一的数据结构

数据的逻辑结构是一张二维表

二维表的列叫做属性，行叫做元组

**属性**

每个属性可能的取值范围(集合)叫做属性的`域`

属性的值通常是原子的，不可再分

空值null：一个特殊的值，表示未知或不存在



**关系的基本概念**

笛卡尔积
$$
D_1\times D_2\times ...\times D_n
$$
的自己叫做在域D1,D2,...,Dn上的关系，用R(D1,D2,...,Dn)表示

R：关系的名字

n：关系的度或目



**关系的性质**

- 关系是无序的(元组的顺序是无关紧要的)
- 列是同质的
- 不同的列来自同一域，每列必须有不同的属性名-
- 列的次序可以任意交换(有的数据库产品不行)

- 两个元组不能完全相同(很多关系数据库没有遵循)

- 每一分量都是不可再分的(1NF)



### 关系模式和实例

R=A1,A2,...,An 是一个关系模式 (A1,A2,...,An是属性)

关系模式的当前值称为实例，可用一个表指定

数据库由多个关系组成



### 码

码的作用：区分给定关系中的不同元组的方法

超码：一个或多个属性的集合，这些属性可以使我们在关系中唯一地标识一个元组

候选码：最小的超码称为候选码

主码：从一个关系的多个候选码中选定一个作为主码

外码：一个关系模式R1可能在它的属性中包含另一个关系模式R2的主码，这个属性称作在R1上参照R2的外码(R1,R2可以是同一个关系)

- 关系R1称为外码依赖的参照关系
- 关系R2称为外码的被参照关系



**关系模式的完整性约束**

`实体完整性`

关系的主码中的所有属性值不能为空值

`参照完整性`

如果关系R2的外部码Fk与关系R1的主码Pk相对应，则R2中的每一个元组的Fk值或者等于R1 中某个元组的Pk 值，或者为空值

`用户定义的完整性`

用户针对具体的应用环境定义的完整性约束条件



### 关系代数

关系代数是一种过程化语言

**六种基本运算符**

- 选择 σ
- 投影 Π
- 更名 ρ
- 并 ∪
- 集合差 -
- 笛卡尔积 X

关系代数的运算以一个或两个关系作为输入，产生一个新的关系作为结果



**选择运算**
$$
ρ_p(r)=\{t\in r~and~p(t)\}
$$
p是一个命题演算公式，由$\and\or\neg$把项连接起来构成

选择运算以行的角度进行运算



**投影**
$$
\Pi_{A1,A2,...,A_k}(r)
$$
Ai：属性名

结果由选择的k列组成，关系是集合，重复的元组从结果中删除

投影操作主要是从列的角度进行的运算

**并运算**
$$
r ∪s=\{t| t\in r ~or~t \in s\}
$$
r和s必须是同元的 (属性数目相同)

属性的域必须相容

**集合差**
$$
r -s=\{t| t\in r ~and~t \not\in s\}
$$
r和s必须是同元的 (属性数目相同)

属性的域必须相容



投影和并满足分配律

投影和差不满足分配律



**笛卡尔积**
$$
r \times s=\{(r1,r2,..,r_n,s_1,s_2,..s_m)|(r_1,r_2,...r_n)\in r~and~ (s_1,s_2,...,s_m)\in s\}
$$
如果关系r和s的属性有交集，必须使用更名运算



**更名运算**

允许通过更名来引用关系代数表达式的结果
$$
ρ_x(E)
$$
返回被更名为X的表达式E的结果

如果关系表达式E是n元的
$$
ρ_{x(A_1,...,A_n)}(E)
$$
返回被更名为X的表达式E的结果，并且属性被更名为A1,A2,...,An



**关系表达式嵌套**

关系代数中基本的表达式是：

- 数据库中的一个关系
- 一个常数关系



### 附加的关系代数运算

**集合交**
$$
r∩s=\{t|t\in r ~and~ t\in s\}
$$
r和s是同元的

r和s属性的域相容



$\theta$**连接**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%CE%98%E8%BF%9E%E6%8E%A5.png)

θ为算术比较符



**自然连接运算**
$$
r\Join s
$$
关系r和s分别是模式R和S的实例

则$r\Join s $是由如下方式得到的R∪S的关系:

- 对于r中的每个元组$t_r$和s中的每个元组$t_s$所组成的元组对
- 如果$t_r$和$t_s$在R∩S的属性上有相同的值，则在结果中加入一个元组t且
  - t在r上和$t_r$有相同的值
  - t在s上和$t_s$有相同的值

自然连接满足交换律和结合律



**赋值运算**

将查询结果赋值给一个临时的关系变量

**外连接**

外连接是连接运算的扩展，可以处理缺失的信息

计算连接，然后一个关系中失配的元组添加到结果中

使用空值(null)

- 左外连接
- 右外连接
- 全外连接



**空值**

元组的一些属性可以为空值，用null表示

含null的算数表达式结果为null

两个null看作同样的值



空值的比较运算中

除了永真式和矛盾式，其他结果都为unkown



**除运算**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%99%A4%E6%B3%95%E5%AE%9A%E4%B9%89.png)

象集

关系R(X,Y),X,Y是属性组，x是X上的取值，定义x在R中的象集为
$$
Y_x=\{t[Y]|t\in R \and t[X]=x\}
$$
从R中选出在X上取值为x的元组，去掉X上的分量，只留Y上的分量



除运算也可以写为
$$
temp1\leftarrow \Pi_{R-S}(r)\\
temp2\leftarrow \Pi_{R-S}(temp1\times s)-\Pi_{R-S,S}(r)\}\\
result=temp1-temp2\\
$$
除操作是同时从行和列的角度进行运算的



### 扩展的关系代数运算

**广义投影**

广义投影运算通过允许在投影列表中使用算术函数来对投影进行扩展 
$$
\Pi_{F_1,F_2,...,F_n}(E)
$$
Fi是涉及常量以及E的模式中属性的算术表达式



**聚集函数和聚集运算**

聚集函数 输入值的一个汇集，将单一值作为结果返回

- avg 平均值
- min 最小值
- max 最大值
- sum 求和
- count 计数

聚集运算在关系代数中
$$
G_1,G_2,...,G_n γF_1(A_1),F_2(A_2),...,F_n(A_n)(E)
$$
E是任一关系代数表达式

- Gi是用于分组的一系列属性 可以为空
- Fi是一个聚集函数
- Ai是一个属性名



聚集的结果没有名称，可以用更名运算给他命名

为了方便，我们允许将更名作为聚集运算的一部分  as



**多重集关系代数**

纯关系代数删除所有重复

多重集关系代数保存重复，匹配SQL语义



## SQL

### 数据定义语言

SQL的数据定义语言DDL能够定义每个关系的信息，包括：

- 每个关系的模式
- 每个属性的值域
- 完整性约束
- 以后将要看到的一些信息，比如
  - 每个关系的索引集合
  - 每个关系的安全性和权限信息
  - 磁盘上每个关系的物理存储结构



#### **SQL中的基本类型**

- char(n). 固定长度的字符串，长度为n
- varchar(n). 可变长的字符串  最大长度n
- int 整数类型
- smallint 小整数类型
- numeric(p,d) 定点数，精度由用户指定，这个数有p位数字，其中d位数字在小数点右边
- real,double precision 浮点数与双精度浮点数，精度与机器相关
- float(n).浮点数，精度至少为n位



#### **创建表结构**

使用create table命令创建一个SQL关系表

```sql
create table r (A1 D1,A2 D2,...,An Dn , (integrity-constraint t1,...,integrity-constraint tk))
```

r：关系名

Ai：属性名

Di：属性Ai的域的类型

ti：完整性约束

- not null
- primary key (A1,...,An)
- foreign key(Am,...,An) references r

声明为主码的属性自动确保为not null



#### **删除和更改表结构**

**drop table**

```
drop table <表名> [RESTRICT | CASCADE]
```

RESTRICT：删除表是有限制的

删除的基本表不能被其他表的约束所引用，否则表不能被删除

CASCADE：删除该表是没有限制的

在删除基本表的同时，相关的依赖对象一起删除



```sql
delete from <表名>
```

删除表中内容，但是保留表



**alter table**

```sql
//属性A是关系r将要增加的属性，D是A的域
//对于关系r中的所有元组，在新增加的属性上的取值都为null
alter table r add A D

//删除属性
alter table r drop A

//修改已存在的表 r 中的列 A 的属性。可以改变列的数据类型、大小、约束等
alter table r modify A

//删除表中约束
alter table 表名 drop constraint 约束名
```



### SQL数据查询功能

#### 基本查询结构

SQL的数据操纵语言DML提供从数据库中查询信息；插入、删除、修改元组的能力

一个典型的sql查询形式为：

```sql
select A1,A2,..,An
from r1,r2,...,rm
where P
```

#### select 子句

相当于关系代数中的投影运算，用于列出查询结果中所需要的属性

select子句的<目标列表达式>可以为

- 算术表达式
- 字符串常量

- 函数
- 列别名

SQL中允许关系和查询结果中保留重复的元组，如果想去重，需要在select后使用关键字distinct

```sql
select distinct ...
from ...

//select all 显示指明不去重复

*表示所有属性
select * 
from ...

select 子句可包含算术表达式

select ID,name,salary/2
from instructor
```

#### where子句

相当于关系代数中的选择谓词，指定查询结果必须满足的条件

语法成分：

- 逻辑运算符
- 比较运算符
- between条件

判断表达式的值是否在某范围内



#### from子句

与关系代数中的笛卡尔积运算相对应

一般不直接使用，而是与where子句一起使用



#### 连接查询及执行过程

同时涉及多个表的查询称为连接查询

用来连接两个表的条件称为连接条件或连接谓词 

一般格式
$$
[<表名1>.]<列名1>  <比较运算符>  [<表名2>.]<列名2>\\
[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
$$
**连接字段**

连接谓词中的列名称，连接条件中的各连接字段类型必须是可比的，不必是相同的



**执行过程**

- 嵌套循环法
- 排序合并法
- 索引连接法



#### 自然连接

**natural join**

自然连接只考虑两个关系模式中都出现的属性上取值相同的元组对，并且相同属性的列只保留一个副本

```sql
select * from instructor natural join teachers
```

自然连接中的危险：有些属性具有相同的名称，但是它们实际的意义是不同的



#### 更名运算

SQL允许使用as子句对关系和属性进行更名运算

```sql
old-name as new-name
```

as 是可选的，可以省略(Oracle中必须省略)

```sql
instructor as T = instructor T
```



#### 字符串运算

**like操作符**

SQL通过字符串匹配运算符来支持字符串上的比较，使用like操作符来实现模式匹配.使用两个特殊字符(通配符)描述模式

- 百分号(%) 匹配任何字串
- 下划线(_) 匹配任何字符

like具有单向性

```sql
'济南市山大路' like '济南市%' ture
'济南市%' like '济南市山大路' false
```

转义字符\

字符串的值是大小写敏感的



SQL支持的串运算：

- 串联 ||
- 大小写转换
- 计算串长度，抽取字串



**SQL正则表达式**

- REGEXP_LIKE(匹配)
- REGEXP_INSTR(包含)
- REGEXP_REPALCE(替换)
- REGEXP_SUBSTR(提取)

```sql
Select * from table1
  where REGEXP_LIKE(SJHM, ‘^[1]{1}[35]{1}[[:digit:]]{9}$‘)
```

- ^代表开始
- $表示结束
- []内部为匹配范围
- {}里的内容表是个数，有几位



#### 排列元组的显示次序

只是显示次序排序，只能是sql的最后一个子句，只能出现目标列内的字段

ASC,DESC



#### 重复

对于存在重复元组的关系，SQL可以决定在结果中显示该元组的几个副本



#### 集合运算

集合运算 union,intersect,except

自动去重

如果要保留重复

union all,intersect all,except all



#### 空值

元组的一些属性可以为空值，用null表示



带有null的任何比较运算返回unkown

三值逻辑使用真值 unknown：

除了永真式和矛盾式，其他的公式结果全部为unknown

where 将unknown 作为false来处理



#### 聚集函数

聚集函数以一个值的集合为输出，返回单个值

- avg
- min
- max
- sum
- count

聚集函数默认作用于多重集，作用于集合 使用distinct

```sql
select count(distinct ID)
```

SQL返回关系，返回的关系有且只有一行

Select子句中出现聚集函数，不能同时出现非聚集的属性



**Group By 子句**

在关系的自己上运用聚集函数，得到一个新的关系



GROUP BY子句的作用对象是查询的中间结果表



使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和聚集函数,不能出现非聚集的非分组属性



having是对分组聚集的结果进行选择



**空值和聚集**

除了count(*) ，其他的聚集运算都忽略聚集属性上位空值的元组

如果集合只有空值,count运算值为0，其他运算返回空值



#### 嵌套子查询

一个子查询是一个嵌套在其他的查询中的select-from-where 表达式

子查询常用于对集合成员的资格、集合的比较、集合基数进行检查

**集合成员的资格(in)**

```sql
找出在2009年秋季和2010年春季同时开课的所有课程
select distinct course_id
from section
where semester = ’Fall’ and year= 2009 and  course_id  in
				(select course_id
                                 from section
                                 where semester = ’Spring’ and year= 2010)
 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程
select distinct course_id
from section
where semester = ’Fall’ and year= 2009 and  course_id  not in (select course_id
                                 from section
                                 where semester = ’Spring’ and year= 2010);

```

**集合的比较(some,all)**

```sql
找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高 
select name
from instructor
where salary > some (select salary
                                     from instructor
                                     where dept_name = ’Biology’);
                                     
 找出满足下面条件的所有教师的姓名，他们的工资值比Biology系每个教师的工资都高 
select name
from instructor
where salary > all (select salary
                                from instructor
                                where dept_name = ’Biology’);
也可以简化不写all
```



**空关系测试**

exists，not exist

exists结构测试子查询结果是否有元组，子查询非空时，返回true



in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为`相关子查询`

子查询的`相关变量`是指在子查询中使用的，但其值取决于外部查询（也就是主查询）中的变量



**sql中“全部”概念的处理**

- 超集

not  exists(X except Y)

- 全称量词

not exists(not exists)

- ÷

not in(not in)



**测试重复的元组**

unique结构测试一个子查询的结果中是否有重复的元组

not unique



#### from子句中的子查询

SQL允许在from子句中使用子查询表达式

```sql
找出系平均工资超过42000美元的那些系中教师的平均工资 
    select dept_name, avg_salary
    from (select dept_name, avg (salary) as avg_salary       
          from instructor        
          group by dept_name)
          where avg_salary > 42000;

```

Lateral 子句允许 from 子句中后面的部分 （在关键词 lateral 后面的）访问前面部分的相关变量 

```
 select name, salary, avg_salary
 from instructor I1, 
 lateral (select avg(salary) as avg_salary
 from instructor I2
 where I2.dept_name= I1.dept_name);
```

#### with子句

with子句提供了定义临时关系的方法，这个定义支队包含with子句的查询有效

```sql
找出具有最大预算值的系
with max_budget (value) as 
(select max(budget)
from department)
select budget
from department, max_budget
where department.budget = max_budget.value;

```



#### 标量子查询

标量子查询只返回包含单个属性的单个元组

如果子查询的结果返回多个元组，则会产生运行错误

```sql
select dept_name, 
(select count(*) 
 from instructor 
 where department.dept_name=instructor.dept_name)
 as num_instructors
 from department;
```



### 数据库的修改

#### 删除

从表中删除符合条件的元组，如果没有where语句，删除所有元组

```sql
delete from 表名 where 条件表达式
```

```sql
删除工资低于大学平均工资的教师记录
delete from instructor
where salary<(select avg(salary) from instructor)
```



#### 插入

插入一条指定好值的元组

```sql
insert into 表名 [列名,...]
values (值,...)
```

插入多条元组

```sql
insert into 表名 (列名,...)
(子查询)
```



**几种特殊用法**

```sql
向 student 关系中插入新元组，并将tot_creds 属性设置为null
 insert into student
 values (‘3003’, ‘Green’, ‘Finance’, null);

将instructor 关系中的所有元组插入到student 关系里，并将属性tol_credits设置为0
 insert into student
 select ID, name, dept_name, 0
 from   instructor

```



#### 更新

```sql
update 表名
set 操作
where 谓词
```



case语句

```sql
update instructor
set salary=case
when salary<=100000 then salary*1.05
else salary*1.03
end
```



也可以通过标量子查询来更新数据库



## 中级SQL

### 连接表达式

**连接关系**

连接操作作用于两个关系并返回一个关系作为结果

Join操作通常用作from子句中的子查询表达式



连接操作将两个关系作为输入，并返回一个关系作为结果 这些额外的操作通常用作from子句中的子查询表达式

 连接条件 – 规定了这两个关系中的哪些元组匹配，以及在连接结果中出现什么属性

 连接类型 – 规定了对每个关系中（基于连接条件）不与其他关系中的元组相匹配的元组怎样处理 



**连接类型**

- 内连接
- 左外连接
- 右外连接
- 全外连接

**连接条件**

natural

on <谓词>

using <A1,A2,...,An>



在表名后面加外连接操作符(*)或(+)指定非主体表

非主体表有一“万能”的虚行,该行全部由空值组成

虚行可以和主体表中所有不满足连接条件的元组进行连接



### 视图

#### 视图创建

使用create view命令定义视图,命令格式为

```sql
create view v as <query expression>
```

其中<query expression> 可以是任何合法的SQL表达式 v表示视图名 

一旦定义了一个视图，我们就可以用视图名指代该视图生成的虚关系 



**特点**

- 视图是一个虚表，从一个或几个基本表导出的关系
- 只存放视图的定义，不会出现数据冗余
- 基表的数据发生变化，视图中查询出的数据也随之改变
- 查询时，视图名可以出现在任何关系名可以出现的地方



与派生查询(with)不同的是

视图存储在DB数据字典中，是数据库模式的一部分

with定义的派生关系，仅在所属的SQL有效，不属于DB模式



视图与表

- 都是关系，可以在SQL中直接应用
- DB中存储表的模式定义和数据，而只存储视图的定义
- 视图数据在使用表时临时计算
- 物化视图时提高计算的一种手段



视图的作用：对外模式的支持，安全性，方便性



#### 使用其他视图定义视图



可以使用另一个其他视图来定义视图

如果一个视图v2用于定义另一个视图v1的表达式，则称v1直接依赖于v2

如果一个视图关系v1 直接依赖于另一个视图关系v2，或通过其他视图间接依赖于v2，则称v1 依赖于v2

一个视图关系如果依赖于它自身，则被称为递归的 



#### 视图更新

通过update、delete等语句的使用，可以实现视图更新

所有对视图的更新，都会转化为对基础表的更新



**有些更新不能被单独执行**

大部分SQL实现只允许在简单试图上的更新

- from子句中只有一个数据库关系
- select子句中只包含关系的属性名，不包含任何表达式、聚集函数或distinct声明
- 任何没有出现在select子句中的属性可以取空值
- 查询中不包含groupby或having子句



**with check option**

视图定义时，指定with check option，强制通过视图进行的修改，结果必须在视图中（更新后的元组必须满足视图的定义，否则更新会被DBMS拒绝）



#### 物化视图

创建一个物理表，包含了视图查询结果的所有元组



why?

- 提高查询性能，空间换时间
- 物化视图对应用透明
- 基表发生变化，物化视图也应当刷新
- 规模较大的报表适合使用物化视图来提高查询性能



### 事务

事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位

事务具有

- 原子性

事务中包含的所有操作，要么全做，要么全不做

- 持久性

事务一旦提交，对数据库的影响必须是永久的

- 一致性

事务的隔离执行必须保证数据库的一致性

- 隔离性

系统必须保证事务不受其他并发执行事务的影响



事务以commit work 或 rollback work结束



大多数数据库默认每个SQL语句自动提交



### 完整性约束

**单个关系上的约束**

- not null
- primary key

主码值不允许为空，也不允许重复

- unique

声明一个候选码,候选码属性可以为空，不能重复

- check (P),P是谓词

只有对表的更新操作会触发check子句



**参照完整性**

A是一个属性的集合，R和S是两个包含属性A关系，并且A是S的主码 如果对于每个在R中出现的A在S中也出现，则A被称为R的外码



**级联行为**

删除(修改)基本关系元组

- RESTRICT

只有当依赖关系中没有一个外码值与要删除(修改)的基本关系的主码值相对应时，才能删除该元组

- CASCADE

将依赖关系中所有外码值与基本关系中要删除(修改)的主码值所对应的元组一起删除(修改)

- SET NULL

删除基本关系中元组时，将依赖关系中与基本关系中被删(修改)主码值相对应的外码值置为空







声明

```sql
FOREIGN KEY (S#) REFERENCES S(S#)  [ON DELETE [CASCADE | SET NULL] ]
```



### SQL的数据类型与模式

#### SQL固有的数据类型

- date：日期包括年(四位)、月、日

date '2005-6-24'

- time 时间

time '09:00:30'

- timestamp 

timestamp  ‘2005-7-27 09:00:30.75’

- interval 时间段

interval  ‘1’ day

两个 date/time/timestamp 类型值相减产生一个interval 类型值

可以在 date/time/timestamp 类型的值上加减interval 类型的值



**默认值**

可以为属性指定默认值

```sql
sex char(1) default '1'
```



**创建索引**

```sql
create index index_name on 表名(属性列)
```



**用户自定义类型**

```sql
create type type_name as 

create type Dollars as numeric(12,2) final

final:不能指定一个基于Dollars的新类型

结构化
create type person
(pid char(18)
name varchar(8));
```

进行强类型检查

**创建域**

```sql
create domain domain_name 

create domain degree_level varchar (10)
constraint degeree_level_test 
check (value in('Bachelors','Masters','Doctorate'))
```

不进行进行强类型检查，支持强制类型转换



#### 大对象类型

大对象以large object类型存储

blob:二进制数据的大对象数据类型

clob:字符数据的大对象数据类型



查询结果时指向这个大对象的指针，并非大对象本身



存储实现：指针+文件



LOB访问： 一般用专用语句访问

oracle 

```sql
SelectBlob  doc  into …
	from book
	where cno=‘c1’;
```

### 授权

**权限图**

结点是用户，根结点是DBA，有向边Ui→Uj，表示用户Ui把某权限授给用户Uj

一个用户拥有权限的充分必要条件是在权限图中有一条从根结点到该用户结点的路径



**授权形式**

Read - 允许读取，但是不能修改数据 

Insert - 允许插入新数据，但是不能修改已有数据 

Update - 允许修改，但是不能删除数据 

Delete - 允许删除数据 

Index - 允许创建和删除索引 

Resources - 允许创建新关系 

Alteration - 允许增加或删除关系的属性 

Drop - 允许删除关系 



all privileges 所有允许权限的简写形式

#### SQL授权规范

**grant语句**

```sql
grant 语句用于授予权限
		grant <权限列表>
		on <关系名或视图名> to <用户/角色列表>
```

<用户/角色列表> 是：

一个用户的id

public，所有合法用户持有所授权限

一个角色



对属性列的授权必须明确指出相应属性列名



应用程序的授权由应用程序本身完成，SQL授权机制被忽略



**收回授权**

```sql
revoke 语句用于收回授权
revoke <权限列表>
on <关系名或视图名> from <用户/角色列表>
```

<权限列表> 可以是 all ，表示收回被收回人持有的所有权限

如果<revokee-list> 包含public的话，则除了显式地被授予权限的用户外，所有的用户都将失去权限 

如果同一权限由不同的授权人两次授予同一用户，用户在一次权限被回收后，仍保持有权限 

收回权限时，若该用户已将权限授予其它用户，则也一并收回



**角色**

```sql
create role 角色名
```

角色可以被授以权限

角色可以授以用户，也可以被授以其他角色



**视图的授权**

视图的权限和基表的权限是分开管理的。

创建视图的用户必须具有基表的相应权限，而查询视图的用户只需要具有视图的权限

**其他授权特性**

references 权限 创造外码

with grant option子句，可以跟在grant语句最后，表明可以再授予权限，但要保证没有循环授权



## 高级SQL

### 使用程序设计语言访问数据库

动态SQL：允许运行时以字符串的形式构建SQL，提交查询

嵌入式SQL：必须再编译时全部确定，并交给预处理器



#### 动态SQL

##### **JDBC**

一个支持SQL的Java API，用于与数据库系统通信



JDBC支持查询、更新数据、检索查询结果等多种功能

也支持元数据检索



**JDBC与数据库的通信模型**

- 打开一个连接
- 创建一个"statement"对象
- 使用statement对象执行查询、发送查询并取回结果
- 处理错误的异常处理机制



JDBC的基本工作步骤

1. 加载JDBC driver class
2. 打开数据库连接
3. 执行SQL语句
4. 读取结果集合



**程序实例**

```java
try 
	{Class.forName(“oracle.jdbc.driver.oracledriver”);//定义驱动程序
	 Connection conn= DriverManager.getConnection
		("jdbc:oracle:thin:@202.194.7.x:1000:student", "u1","pw1");
	Statement stmt=conn.createStatement();//定义statement
	try{//插入s(s1,甲)
   stmt.executeUpdate("insert into s(sno,snane) values (‘s1’, ‘甲’ )");
   } 	catch (SQLException sqle)//错误处理
		{System.out.println(“could not insert:”+sqle);}
	try {//显示所有学生sno,sname
	    ResultSet rset=stmt.executeQuery("select sno,sname from s");
   	    while (rset.next())
	{
     System.out.println(rset.getString("sno")+":"+reset.getString("sname"));
    }
	    rset.close(); //释放rset
	   }
     catch (SQLException sqle)//错误处理
	{System.out.println(“select sno,sname err:” +sqle);}
	stmt.close();//释放statement
  	conn.close();//释放连接
	}
catch (SQLException sqle)
		{System.out.println(“SQLException:”+sqle);}

```



**JDBC 立即执行和预备语句**

立即执行：使用statement类，将sql语句交给DBMS执行，一次语句执行DBMS进行一次语句编译

预备语句执行：使用PreparedStatement类，sql语句执行，首先进行编译，编译结果赋予PreparedStatment的对象，预编译结果可被反复多次执行，JDBC预编译在程序运行中进行



预编译sql支持占位符"?" 相当于宿主变量，只是没有名字，使用数字表示第几个"?"

SQL执行前，要对占位符赋值

```java
PreparedStatement pStmt = conn.prepareStatement( "insert into instructor values(?,?,?,?)");
pStmt.setString(1, "88877");
pStmt.setString(2, "Perry");
pStmt.setString(3, "Finance");   
pStmt.setInt(4, 125000);
pStmt.executeUpdate();    
pStmt.setString(1, "88878");
pStmt.executeUpdate();

```

pStmt.executeQuery()，返回一个结果集（ResultSet）



当有用户的输入做参数时，最好使用预备语句(防止SQL注入攻击)



**元数据特性**

元数据：描述数据的数据



查询结果集元数据

执行完一个查询后，得到一个ResultSet rs

```java
ResultSetMetaData rsmd = rs.getMetaData();
     for(int i = 1; i <= rsmd.getColumnCount(); i++) {
           System.out.println(rsmd.getColumnName(i));
                  System.out.println(rsmd.getColumnTypeName(i));
	       }
```



数据库元数据

```java
DatabaseMetaData dbmd = conn.getMetaData();
	ResultSet rs = dbmd.getColumns(null, "univdb", "department", "%");
//getColumns的参数：Catalog，Schema模式，Table模式，
//和列模式
//返回：每列一行；行有许多属性
//例如COLUMN_NAME、TYPE_NAME
	while( rs.next()) {
	       System.out.println(rs.getString("COLUMN_NAME"),
                                                        rs.getString("TYPE_NAME");
     }

```

DataBaseMetaData

- JDBC类
- 对DB数据字典进行封装
- 类方法可以读取数据字典元数据
- 频闭了数据字典的具体实现模式
- 对应用提供访问DB数据字典元数据的标准方法

```sql
DataBaseMetaData dbmd;
	dbmd = conn.getMetaData();
	ResultSet rset; rset=dbmd.getColumns(null,"student","s","%") ;
	while (rset.next())  
		{rset.getString("COLUMN_NAME");
			//读取列名
		//rset.getString("COLUMN_TYPE");
			//读取列类型
		…}
	…

```



**JDBC事务控制**

默认情况下，每个SQL语句都被作为一个被自动提交的事务



可以关闭自动提交

```java
conn.setAutoCommit(false);

//显示提交或回滚
conn.commit();
conn.rollback();
```



**JDBC其他特征**

调用函数和过程：

```java
CallableStatement cStmt1 = conn.prepareCall("{? = call some function(?)}");
CallableStatement cStmt2 = conn.prepareCall("{call some procedure(?,?)}");
```

处理大型对象类型:

- getBlob 和 getClob方法返回Blob和Clob对象
- 通过getBytes()从这些对象里得到数据
- 通过一个开放的流与Java Blob或Clob对象相连，更新大对象

```java
blob.setBlob(int parameterIndex, InputStream inputStream).
```

JDBC过于动态化，错误无法被编译器捕捉



SQLJ：java中的嵌入式SQL



##### ODBC

Open DataBase Connectivity(ODBC) 

标准应用程序与数据库服务器通信的标准 

应用程序接口（API） 

- 与数据库建立一个连接

- 发送查询和更新数据库的语句

- 取回结果 



每个支持ODBC的数据库系统都提供一个与客户端程序相连接的“驱动程序”库 



当客户端程序发出ODBC API 请求后，库中的代码就与数据库服务器通信，执行被请求的动作，并取回结果 



ODBC 程序首先分配一个SQL环境变量，然后得到一个数据库连接句柄 



ODBC 使用SQLConnect( )打开和数据库的连接，SQL连接的参数：

- 连接句柄
- 要连接的服务器
- 用户标识符
- 密码

也必须指定arguments的类型：

SQL_NTS表示前一个参数是一个以null结尾的字符串 



```cpp
int ODBCexample()
	{
  RETCODE error; //用于存储 ODBC 函数的返回值，以检查是否有错误发生。
  HENV    env;   // ODBC 环境句柄
  HDBC    conn;  // ODBC 连接句柄
  SQLAllocEnv(&env); //分配一个 ODBC 环境句柄，并将其存储在 env 中
  SQLAllocConnect(env, &conn);//分配一个 ODBC 连接句柄，并将其存储在 conn 中。
  SQLConnect(conn, “db.yale.edu", SQL_NTS, "avi", SQL_NTS, "avipasswd", SQL_NTS); //连接到数据库
  { …. Do actual work … }
  SQLDisconnect(conn); //断开与数据库的连接
  SQLFreeConnect(conn); //释放连接句柄
  SQLFreeEnv(env); //释放环境句柄
}
句柄:句柄是一种标识符，用于标识和操作系统资源，如窗口、文件、数据库连接等;

```



序通过SQLExecDirect 发送 SQL 命令给数据库 

通过SQLFetch( ) 获取结果元组 

SQLBindCol() 将查询结果的属性值与C语言变量进行绑定  

```cpp
char deptname[80];
float salary;
int lenOut1, lenOut2;
HSTMT stmt;
char * sqlquery = "select dept_name, sum (salary)from instructor group by dept_name";
SQLAllocStmt(conn, &stmt);
error = SQLExecDirect(stmt, sqlquery, SQL_NTS);
    if (error == SQL_SUCCESS) {
        SQLBindCol(stmt, 1, SQL_C_CHAR, deptname , 80, &lenOut1);
        SQLBindCol(stmt, 2, SQL_C_FLOAT, &salary, 0 , &lenOut2);
        while (SQLFetch(stmt) == SQL_SUCCESS) {
            printf (" %s %g\n", deptname, salary);
        }
    }
SQLFreeStmt(stmt, SQL_DROP);

```



**ODBC预备语句**

SQL 语句准备：在数据库中先编译

采用占位符：如 insert into account values(?,?,?)

运行时将实际值传递给占位符，反复执行

```cpp
\\准备语句
SQLPrepare(stmt, <SQL String>);
\\绑定参数
SQLBindParameter(stmt, <parameter#>,  … type information and value omitted for simplicity..)
\\执行语句
retcode = SQLExecute( stmt);
```



**更多ODBC特性**

元数据特性

- 找出数据库中所有的关系
- 找出查询结果和数据库中关系的属性名和属性类型



**事务管理**

在默认情况下，每个SQL语句都被认为是一个自动提交的独立事务 

```cpp
//关闭连接的自动提交
SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0);
//事务提交或回滚
SQLTransact(conn, SQL_COMMIT);
SQLTransact(conn, SQL_ROLLBACK);
```



#### 嵌入式SQL

SQL 标准定义了许多语言的嵌入式SQL，如 C，Java和 Cobol

SQL 查询所嵌入的语言被称为宿主语言（host language），宿主语言中使用的SQL结构被称为嵌入式SQL



**EXEC SQL** 语句用于标识对预处理器的嵌入式SQL请求

```CPP
EXEC SQL <embedded SQL statement > END_EXEC
```

确切语法因循宿主语言的惯例



**预编译工作模式**

预编译将嵌入宿主语言的sql，编译成宿主语言的一段代码，执行这段代码，将完成相应sql调用执行



**预编译程序**

一般由DBMS供应商提供，如：oracle

提供的Pro*c有些数据库应用开发工具，将预编译程序与主程序编译器合为一体，如：PowerBuilder



##### 数据库连接

进行数据库访问必须基于数据库连接

```cpp
sqlca.servername="211.87.224.149"
sqlca.userid=…
sqlca.password=…
…
connect sqlca

撤销数据库连接
disconnect sqlca
```

**数据库连接建立与撤销的常用策略**

一般地，数据库连接可以在应用开始时完成

在应用结束时撤销数据库

连接应用执行过程中，可以保持数据库连接，以随时执行sql



##### SQLCA

SQL通讯域SQLCA是一结构

每一嵌入SQL语句的执行情况在其执行完成后写入SQLCA结构中的各变量中

根据SQLCA中的内容可以获得每一嵌入SQL语句执行后的信息,应用程序就可以做相应的处理



在数组语言中声明，是存储结构和函数的综合体

概念提出早于OO

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/sqlca.png)

APP必须对每一条sql的执行请看进行判定,How?

每条sql语句后，APP检查sqlca返回的执行报告

```cpp
select sname into :vname from s where …
if sqlca.sqlcode<>0 then
      报告错误，进行异常处理，必要时中止应用； 
end if 
```



##### 协调操作方式

why? SQL与主语言之间执行方式有差错

- SQL:一次一集合
- C：一次一记录

How? 若一个SQL语句返回多个元组 则使用游标



**主变量**

在SQL语句中使用的主语言程序变量简称为主变量

嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据



类型：输入主变量、输出主变量

输入、输出主变量可能是同一个主变量



指示变量：一个主变量可以附带一个指示变量



如何使用主变量和指示变量？

1. 声明主变量和指示变量

```
BEGIN DECLARE SECTION
	......... 
	.........     (说明主变量和指示变量)
	.........
END DECLARE SECTION

```

2. 使用主变量

说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现

为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志

3. 使用指示变量

指示变量前也必须加冒号标志,必须紧跟在所指主变量之后



在SQL语句以外的部分，可以直接引用主变量和指示变量，无需冒号



**查询结果为单记录的SELECT语句(无需游标)**

```
[例] 根据学生号码查询学生信息。假设已经把要查询的学生的学号赋给了主变量givensno
	EXEC SQL SELECT Sno，Sname，Ssex，Sage，Sdept        	          
		 INTO  :Hsno， :Hname ，:Hsex，:Hage，:Hdept
         FROM  Student
         WHERE Sno=:givensno；
```

INTO子句、WHERE子句和HAVING短语的条件表达式中均可以使用主变量

查询返回的记录中，可能某些列为空值NULL。

如果查询结果实际上并不是单条记录，而是多条记录，则程序出错，DBMS会在SQLCA中返回错误信息 

```cpp
EXEC SQL SELECT Sno，Cno，Grade                      
		    INTO :Hsno，:Hcno，:Hgrade:Gradeid   
						/*指示变量Gradeid*/
            FROM  SC
            WHERE Sno=:givensno AND Cno=:givencno；
如果Gradeid < 0，不论Hgrade为何值，均认为该学生成绩为空值。
```



**使用游标的SQL语句**

使用游标的过程

1. 说明游标

```
EXEC SQL DECLARE <游标名> CURSOR
            FOR <SELECT语句>;
```

2. 打开游标

```
EXEC SQL OPEN <游标名>;
打开游标实际上是执行相应的SELECT语句，把所有满足查询条件的记录从指定表取到缓冲区中
这时游标处于活动状态，指针指向查询结果集中第一条记录
```

3. 推进游标指针并取当前记录

```
 EXEC SQL FETCH [[NEXT|PRIOR|
                 FIRST|LAST] FROM] <游标名> 
  INTO <主变量>[<指示变量>][,<主变量>[<指示变量>]]...;
```

指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理

NEXT|PRIOR|FIRST|LAST：指定推动游标指针的方式 缺省为NEXT

4. 关闭游标

```
 EXEC SQL CLOSE <游标名>;
```

关闭游标，释放结果集占用的缓冲区及其他资源

游标被关闭后，就不再和原来的查询结果集相联系

被关闭的游标可以再次被打开，与新的查询结果相联系



**CURRENT形式的UPDATE语句和DELETE语句**

UPDATE语句和DELETE语句中的子句： 		

```
WHERE CURRENT OF <游标名>   
```

表示修改或删除的是最近一次取出的记录，即游标指针指向的记录 



**利用游标更新数据**

```cpp
//声明游标用于更新，来对游标获取的元组进行更新
declare c cursor for
select *
from instructor
where dept_name = ‘Music’
for update
//对游标c当前位置的元组进行更新
update instructor
set salary = salary + 100
where current of c
```

当游标定义中的SELECT语句带有UNION或ORDER BY子句 ,不能使用CURRENT形式的UPDATE语句和DELETE语句 

why？ 该select语句相当于定义了一个不可更新的视图



### 函数和过程化结构

**过程扩展和存储过程**

sql提供了一种模块语言

允许在SQL中使用if-then-else语句或while循环等定义过程



存储过程

可以在数据库里存储过程，然后再用call语句执行它们



#### SQL函数

定义函数，输入一个系的名字，返回该系教师的数量

```sql
create function dept_count(dept_name varchar(20))
return integer
begin
	declare d_count integer
	select count(*) into d_count
	from instructor
	where instructor.dept_name=dept_name
	return d_count
end
```

我们可以使用这个函数

找出教师数大于12的所有系的名称和预算 

```sql
select dept_name, budget
from department
where dept_count (dept_name ) > 12

```

**表函数**

返回关系作为结果的函数

返回一个包含特定系的所有教师的表

```sql
create function instructor_of(dept_name char(20))
return table(ID varchar(5),name varchar(20),dept_name varchar(20),salary numeric(8,2))

return table
(
    select ID,name,dept_name,salary
    from instructor
    where instructor.dept_name=instructors_of.dept_name
)
```

使用该表

```sql
select *
from table (instructors_of('Music'))
```



#### SQL过程

可以将SQL函数写成一个过程，在其他过程或者嵌入式SQL中使用call语句调用

```sql
create procedure dept_count_proc (in dept_name varchar(20), out d_count integer)
 begin
	  select count(*) into d_count
      from instructor
      where instructor.dept_name = dept_count_proc.dept_name
 end

declare d_count integer;
call dept_count_proc( ‘Physics’, d_count);

```



#### 过程化结构

复合语句 begin...end之间包含复杂的SQL语句

- 可以在复合语句中声明局部变量



while 和 repeat 语句

```sql
declare n integer default 0;
while n < 10 do
set n = n + 1
end while

repeat
set n = n  – 1
until n = 0
end repeat

```



For循环

允许对查询的所有结果重复执行

```sql
declare n  integer default 0;
for r  as
select budget from department
where dept_name = ‘Music’
do
set n = n - r.budget
end for
```



条件语句 if-then-else

确认选课的学生数没有超过该课所在教室的容量

返回0表示成功,返回-1表示容量超出





发信号通知异常条件，声明句柄来处理异常

```sql
declare out_of_classroom_seats condition
declare exit handler for out_of_classroom_seats
begin
…
..  signal out_of_classroom_seats
end

```



#### 外部语言函数/过程

SQL:1999 允许使用其他语言（如C 、 C++）编写的函数和过程

```sql
create procedure dept_count_proc(in dept_name varchar(20),out countinteger)
language C
external name ’ /usr/avi/bin/dept_count_proc’
                                 
```



优点：更强的表达能力

缺点：实现功能的代码可能需要加载到数据库系统并在数据库系统的地址空间中执行 有安全风险

如何保证安全性？

- 沙盒技术 使用一个安全的语言 如java
- 在一个单独的过程里运行外部语言函数/程序，不会对数据库进程的内存进行访问（进程间通信传递参数和结果）



### 触发器

`触发器`是一条语句，当对数据库做修改时，它自动被系统执行 

- 指明什么条件下执行触发器
- 指明触发器执行时的动作



#### 定义触发器

```sql
CREATE TRIGGER <触发器名>  
{BEFORE | AFTER} <触发事件> ON <表名>
FOR EACH  {ROW | STATEMENT}
［WHEN <触发条件>］
<触发动作体>

```

触发器类型:行级触发器（FOR EACH ROW）,语句级触发器（FOR EACH STATEMENT）

触发动作体

触发动作体可以是一个匿名PL/SQL过程块,也可以是对已创建存储过程的调用

**SQL里的触发事件和动作**

触发事件可以是insert，delete 或update

一个更新之前和之后的属性值可以被引用 

referencing old row as:  用于删除和更新

referencing new row as:  用于插入和更新 

触发器可以在一个事件（额外的约束）之前被激活

例如 把空白的成绩写为null

```sql
create trigger setnull_trigger before update of takes
referencing new row as nrow
for each row
when (nrow.grade = ‘ ‘)
begin atomic
set nrow.grade = null;
end;

```



**语句级触发器**

受一个事务影响的所有行可以执行一个单一的整体行动

而不是对每个受影响的行都单独执行行动 

用for each statement 子句代替for each row子句 

用referencing old table子句或referencing new table子句来指向包含所有被影响行的临时表（称为过渡表（ transition tables ）） 

在SQL语句更新大量的行时会更有效 



#### 激活触发器

触发器的执行，是由触发事件激活的，并由数据库服务器自动执行

一个数据表上可能定义了多个触发器，触发器的执行顺序

- 执行before触发器
- 激活触发器的sql语句
- 执行after触发器



#### 删除触发器

```sql
 DROP TRIGGER <触发器名> ON <表名>;
```



### 高级聚集特性

#### SQL递归

```sql
select * from …. where  [结果过滤条件语句]
start with  [and起始条件过滤语句]
connect by prior [and中间记录过滤条件语句] 
```



查询a的所有后代

```sql
select * from parent
start with parent='a'
connect by prior child = parent
```



#### 高级聚集-排名

排名是用order by语句来实现的

求每个学生的名次

```sql
select ID, rank() over (order by GPA desc) as s_rank
from student_grades
```

在拍名中可能会产生隔断，使用dense_rank不会产生隔断



排名可以在不同的区里进行

按系给学生排名

```sql
select ID, dept_name,
rank () over (partition by dept_name order by GPA desc) 
as dept_rank
from dept_grades
order by dept_name, dept_rank;
```

排名与group by子句/聚集同时出现的时候，group by子句/聚集首先执行，排名在其结果上执行 

其他排名函数

percent_rank （在分区完成的情况下，在分区内排名）

cume_dist （累积分布）元组的一部分与前面的值

row_number （可能存在重复）



对于一个给定的常数n，排名函数ntile(n)按照给定的顺序取得每个分区中的元组，并把它们分成n个具有相同元组数目的桶 

```sql
select ID, ntile(4) over (order by GPA desc) as quartile
from student_grades;
```



#### 高级聚集-分窗

窗口查询用来对于一定范围内的元组计算聚集函数



between rows unbounded preceding and current第一行至当前行的汇总

rows unbounded preceding当前行前面的记录

range  between 10 preceding and current row当前行的前10行

range interval 10 day preceding不包括当前行



可以在分区内分窗

```sql
一个关系transaction (account_number, date_time, value)，存款的话值为正，提款的话值为负
求出每个账户上的交易完成后，每个账户的余额
select account_number, date_time,
sum (value) over
(partition by account_number 
 order by date_time
 rows unbounded preceding)
 as balance
 from transaction
 order by account_number, date_time
```



## 数据库设计和ER模型

### ER模型

一个数据库可以建模如下：

- 一组实体集

- 多个实体之间地相互关联

`实体` 现实世界中区别于所有其他对象的一个`事物`或`对象`

实体具有`属性`

`实体集`使相同类型即具有相同性质(属性)的一个实体集合



**联系集**

n>=2个(可能相同的)实体集上的数学联系，如果$E_1,E_2,...,E_n$为实体集，那么联系集R
$$
R=\{(e_1,e_2,...,e_n) e_1\in E_1,...,e_n\in E_n\}
$$
联系集可以具有`描述性属性`

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%81%94%E7%B3%BB%E9%9B%86%E6%8F%8F%E8%BF%B0%E6%80%A7%E5%B1%9E%E6%80%A7.png)

**联系集的度**

二元联系集涉及两根实体集(度为2)，数据库系统中大部分联系集都是二元的



**属性**

实体通过一组属性来表示，属性是实体集中每个成员所拥有的描述性性质

域-每个属性都有一个可取值的集合

**属性类型**

- 简单和复合属性
- 单值和多值属性
- 派生属性
  - 可以从别的相关属性或实体派生出来(如可以从年龄推出出生年份)



### 约束

**映射基数**

一个实体通过一个联系集能够关联的实体的个数，在描述二元联系集时非常有用

- 一对一
- 一对多
- 多对一
- 多对多



**参与**

实体集之间的关联叫做参与，即实体参与联系

如 陈木华选修"数据库基础" 表明实体"陈木华"与“数据库基础”参与了联系“选修”



**码**

实体集的`超码`是一个或多个属性的集合，这些属性的值可以唯一地标识一个实体

实体集的`候选码`是一个最小超码

只有一个`候选码`被选为`主码`



联系集的主码是参与实体集合的主键组合形成联系集的超码



### 冗余属性

同一个属性在两个联系的实体集中重复出现，则称这个属性是冗余的，需要将其移除



### 实体-联系图

分成两部分的矩阵代表实体集

菱形代表联系集

属性在实体集矩形中列出

构成主码的属性以下划线表明

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%AE%9E%E4%BD%93-%E8%81%94%E7%B3%BB%E5%9B%BE.png)



**拥有复合、多值、派生属性的实体**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%B7%E6%9C%89%E5%A4%8D%E5%90%88%E3%80%81%E5%A4%9A%E5%80%BC%E3%80%81%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9E%E4%BD%93.png)

**拥有属性的联系集**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%8B%A5%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E8%81%94%E7%B3%BB%E9%9B%86.png)

**角色**

一个关系的实体集必须是互异的

实体在联系中扮演的功能称为实体的角色

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%AE%9E%E4%BD%93%E7%9A%84%E8%A7%92%E8%89%B2.png)

"course_id" "prereq_id"就是角色



**基数约束**

用箭头或者线段表示基数约束

箭头指向一的一方

线段连接多的一方

如：一对多关系

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.png)



**联系集中实体集的参与**

- 全部参与

实体集中的每个元素在联系集中至少参与了一个关系，用双线表示

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%A8%E9%83%A8%E5%8F%82%E4%B8%8E.png)

- 部分参与：一些实体在联系集中可能不参与任何关系



**基数限制的可选标记**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%9F%BA%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E5%8F%AF%E9%80%89%E6%A0%87%E8%AE%B0.png)

基本的基数约束

m:1 多对1

m:n 多对多

更精确的基数约束

给出上下界约束 1...h

0...*等价于多

0...1 等价于1



**上下界约束**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BA%A6%E6%9D%9F.png)

一门课至少有20个学生学习

一个学生要学3到5门课



**一个三元关系的E-R图**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E4%B8%89%E5%85%83%E5%85%B3%E7%B3%BBER%E5%9B%BE.png)

只能有一个箭头，否则会导致歧义



**弱实体集**

没有足够的属性以形成主码的实体集称作`弱实体集`

弱实体集依赖于`标识实体集`

`标识性联系`

标识性联系以双菱形标识

标识性联系是从弱实体集到标识实体集多对一的，并且弱实体集在联系中的参与是全部的

弱实体的`分辨符`用于区分依赖于特定强实体集的弱实体集中的实体的属性的集合

弱实体集的主码是由标识实体集上的主码加上弱实体集的分辨符狗策划给你

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%A8%E9%83%A8%E5%8F%82%E4%B8%8E.png)

Section的主键-(course_id,sec_id,semester,year)



**概念数据库设计过程**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1(1).png)

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1(2).png)

**消除冲突**

- 属性冲突

属性的类型、取值范围、单位不同

- 命名冲突
  - 同名异义
  - 异名同义

- 结构冲突

同一对象在不同应用中的抽象不同

如：职工在某应用中是实体，在另一应用中则抽象为属性

同一实体在不同E-R图中属性组成不同

实体之间的联系在不同E-R图中呈现不同的类型



### ER模型转化为关系模式

1. E-R图转化为表并进行必要的合并
2. 优化



**具有简单属性的实体集的表示**

用具有n个不同属性的模式E来表示强实体集

student($\underline{ID}$, name, tot_cred)

用包含标识性强实体集的主键作为列构成的表表示弱实体集

section($\underline{course\_id,sec\_id,sem.year}$)



**联系集的表示**

两根参与实体集主键属性和联系集中任何描述属性所组成的模式
$$
advisor(\underline{s\_id,i\_id})
$$
教师指导学生



**模式的冗余**

一对多和多对义关系中全部参与的"many"一方可以通过增加额外的属性来表示 (包含"one"一方的主键)

如学生和宿舍的关系， 学生添加一个dept_name 表示学生入住宿舍的关系

一对一联系集，任意一方可以作为"many"方

若"many"一方是部分参与，则增加的额外属性可能为空值



连接弱实体集与其依赖的强实体集的联系集的模式是冗余的



**复合多值属性**

复合属性可以再划分为更小的部分

多值属性可以用一个单独的关系模式表示

特别的，如果除了主键属性只有一个属性，且属性为多值的，可以直接创建对应的多值属性

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%A4%9A%E5%80%BC%E5%B1%9E%E6%80%A7.png)

time_slot($\underline{time\_slot\_id, day, start\_time}, end\_time$)



### 设计问题

**使用实体集还是联系集**

当描述发生在实体间的行为采用联系集

（其实用实体集也可以，但联系集更简洁）

**二元联系还是n元联系**

尽管任何非二元联系都可以用几个不同的二元联系集替代，但是n元联系集能更清楚的表示几个实体在单个联系中的参与情况

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%B0%86%E9%9D%9E%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB.png)

约束也需要转化



### 扩展的E-R特性

**特化**

自顶而下设计过程; 实体集可能包含一些子集，子集中的实体在某些方面区别于实体集中的其他实体

这些子集变为低层次的实体集，拥有不适用于高层次实体集的属性或一些部分参与的关系

在E-R图中，**特化用从特化实体指向另一个实体的空心箭头来表示**，我们称这种关系为ISA关系 (E.g., instructor “is a” person)

**属性继承** – 高层实体集的属性可以被低层实体集继承。低层实体集（或子类）同时还继承地参与其高层实体（或超类）所参与的实体集

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%89%B9%E5%8C%96.png)

**概化**

`自底而上的设计过程`– 多个实体集根据共同的特征综合成一个较高层的实体集

概化不过是特化的逆过程



`特化/概化上的约束`

实体可以是给定低层次实体集成员的约束

如：65岁以上的所有顾客都在 senior-citizen entity集合中



一个概化中一个实体是否可以属于多个低层次实体集

- 不相交(Disjoint)要求一个实体至多属于一个地层实体集
- 重叠 同一个实体可以同时属于同一个概化中的多个低层实体集



`完全性约束`

定义高层实体集中的一个实体是否必须至少属于该概化/特化的一个低层实体集

- 全部概化 每个高层实体必须属于一个低层实体集

- 部分概化 允许一些高层实体不属于任何低层实体集



**聚集**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%81%9A%E9%9B%86%E4%BE%8B%E5%AD%90.png)

假设每位在项目上指导学生的教师需要记录月评估报告

联系集 eval_for 和 proj_guide 代表重叠信息

- 每个 eval_for 关系和一个proj_guide关系相关

- 然而，一些proj_guide可能不和任何eval_for相关



通过聚集来减少冗余

- 将联系作为抽象实体

- 允许联系间存在联系

- 将联系抽象用于新实体

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%81%9A%E9%9B%86.png)



**模式表示特化**

为高层实体集创建一个模式 

为每个低层实体集创建一个模式，模式中的属性包括对应于低层实体集的每个属性，以及对应于高层实体集主码的每个属性。

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%80%9A%E8%BF%87%E6%A8%A1%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%89%B9%E5%8C%961.png)

缺点：想获得员工的信息需要访问两个关系



方法2

利用低层实体集的每个属性和对应于高层实体集的每个熟悉创建模式

如果特化是完全的，不需要存储概化实体集的信息

缺点：对于又是学生，又是员工的人存储冗余的信息

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%A8%A1%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%89%B9%E5%8C%962.png)



**聚集转化为关系模式**

- 聚集关系的主键
- 相关实体集的主键
- 任何描述属性



## 关系数据库设计

### 原子域和第一范式

原子域：域元素被认为是不可分割的单元(根据具体情况而言)



**第一范式**

若一个关系模式R属于第一范式，则R的所有属性都是原子的



why?非原子的属性会使存储变得复杂并且会导致数据存储的冗余



### 利用函数依赖进行分解

**函数依赖**

考虑一个关系模式R



$\alpha \subseteq R $ 且 $\beta \subseteq R $

函数依赖$\alpha \to \beta$满足的条件是对实例r中所有元组对t1和t2
$$
t_1[\alpha]=t_2[\alpha] \Rightarrow t_1[\beta]=t_2[\beta]
$$
如果R的每个合法实例r都满足函数依赖，则称该函数依赖在R上成立



函数依赖：

- 在合法关系集合上的约束
- 要求一个特定的属性集合的值决定另一个属性集合的值
- 是一个码标识的概化

- 函数依赖使我们能够表示不能由超码表示的约束



**平凡的函数依赖**

对于所有关系模式R，如果
$$
\beta \subseteq \alpha
$$
则
$$
\alpha \to \beta
$$
一定成立，即$\alpha \to \beta$是平方的函数依赖

否则，称$\alpha \to \beta$未非平方的函数依赖，即α是β的实质决定因素



**部分函数依赖**

在R(U)中，如果$\alpha \to \beta$ ，且对于任意$\alpha$的真子集$\alpha'$，都有$\alpha' \not \to \beta$

则称$\beta$对α完全函数依赖，记作
$$
α \stackrel{f} {\longrightarrow} β
$$
否则称β对α部分函数依赖，记作
$$
α \stackrel{p} {\longrightarrow} β
$$
**传递函数依赖**

在R(U)中，如果
$$
α\to β，β\toγ，β\not \toα，且β\not \sub α
$$
则称γ对α传递函数依赖



**函数依赖是模式的约束**

函数依赖是对关系模式的约束，其限制了关系模式可能的实例

关系模式在研究函数依赖后，应该描述为四元组
$$
R(U,D,dom,F)
$$
U 属性的集合，理解为表的字段集合。

D 属性的域，理解为表中字段的类型集合。

DOM 属性向域的映射关系，理解为每个字段具体的取值。

F R成立的函数依赖集合

关系模式常简单表示为 R(F)



**函数依赖与码**

- 超码SuperKey

对于关系模式R
$$
\alpha \subseteq R
$$
如果
$$
\alpha \to R
$$
则α为超码



- 候选码CandidateKey

对于关系模式R，α为超码，如果任意α的真子集β，都有
$$
\beta \not \to R
$$
则称α为候选码



**关系实例满足的函数依赖**

对于关系模式R(F)，如果$r\in R(F)$,则

1. R上成立的所有函数依赖，r必须满足
2. r上满足的函数依赖，R上不一定成立



**函数依赖集合的闭包**

给定函数依赖集F，必定有一些其他的函数依赖可以被F逻辑蕴含

能够从给定的F集合推导出的函数依赖的集合称为F的闭包，记作
$$
F^+
$$
任何计算$F^+$的算法一定是NP的



**2NF 第二范式**

解决什么问题？ `某些属性部分函数依赖于码`

如何解决? `将关系模式分解成若干个关系模式，以消除这些部分函数依赖`



若$R\in1NF$,且每个非主属性都完全函数依赖于码，则$R\in2NF$



**Boyce-Codd范式**

具有函数依赖集F的关系模式R属于BCNF的条件是，对$F^+$中所有形如$\alpha \to \beta$的函数依赖，下面至少有一项成立：

- $α\toβ$是平凡的函数依赖
- α是模式R的一个超码

也就是说，每一个决定属性因素都包含码



**分解一个模式称为BCNF**

假设有一个关系模式R和一个非平凡依赖$\alpha \to \beta$违反BCNF，这时可将R分解为
$$
\alpha \cup \beta
$$

$$
(R-(\beta-\alpha))
$$

BCNF的设计是不保持依赖的，由于常常想保持依赖，接下来介绍另一种比BCNF弱的范式，它允许保持依赖,该范式称为第三范式



**第三范式**

关系模式属于第三范式，对于所有
$$
\alpha \to \beta\ in\ F^+
$$
以下至少一项成立

- $\alpha \to \beta$是一个平凡的函数依赖
- α是R的一个超码
- β-α中的不同属性可能包含于不同的候选码中

一个属于第三范式的关系模式，每一个非主属性既不部分依赖于码也不传递依赖于码



`BCNF是第三范式的真子集`



### 函数依赖理论

我们可以反复运用Armstron's Axioms得到$F^+$

- 自反律

$$
\beta \subseteq \alpha \Rightarrow \alpha \to \beta
$$



- 增补律

$$
\alpha \to \beta \Rightarrow γ\alpha \to γ\beta
$$

- 传递律

$$
\alpha \to \beta \and\beta \to γ \Rightarrow \alpha \to γ
$$

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/Armstrong%20%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F.png)

```sql
F+ = F 
repeat
    for each F+中的函数依赖f
        在f上应用自反律和增补律
        将结果加入F+中
        for each F+中的一对函数依赖f1和f2
            if f1和f2可以用传递律结合起来
                then 将结果加入F+中
until F+ 不再变化
```



**属性集的闭包的使用**

- 判断超码

如果一个属性集合的闭包包括了R中所有属性，那么它是一个超码

- 判断函数依赖

通过检查是否存在β$\subseteq \alpha^+$，判断$\alpha \to \beta$是否成立

- 计算F的闭包

对于任意的$γ\subseteq R$，找出闭包γ+，对于任意S$\subseteq γ^+$，输出一个函数依赖$γ\to S$



**无关属性**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%97%A0%E5%85%B3%E5%B1%9E%E6%80%A7.png)

如何检验无关属性

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%A3%80%E9%AA%8C%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E6%97%A0%E5%85%B3.png)



**正则覆盖**

函数依赖集的等价性

- 函数依赖集F,G，若F的闭包等于G的闭包，则称F与G等价

- F与G等价，则称F是G的一个覆盖，G是F的一个覆盖
  $$
  F^+=G^+ \iff F\subseteq G^+ and G\subseteq F^+
  $$

函数依赖集可能拥有可从其他推导出来的冗余的依赖

F的正则覆盖是一个于F相等的最小的函数依赖集，没有冗余的依赖，也没有无关属性



F的正则覆盖Fc是一个依赖集，满足

- F逻辑蕴含Fc中所有依赖
- Fc逻辑蕴含F中所有依赖
- Fc中任何函数依赖都不含无关属性
- Fc中函数依赖的左半部都是唯一的

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96%E7%9A%84%E8%AE%A1%E7%AE%97.png)

**无损分解**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%97%A0%E6%8D%9F%E5%88%86%E8%A7%A3.png)

**保持依赖**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E4%BF%9D%E6%8C%81%E4%BE%9D%E8%B5%96.png)

### 分解算法

**子模式BCNF的判定**

子模式Ri是否是BCNF的判定：

对所有$\alpha \to \beta \in F_i$检查$\alpha \to \beta$是否使Ri违背BCNF定义

算法复杂度分析：NP



**BCNF分解算法**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/BCNF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95.png)

BCNF分解并不能总是保持依赖







**第三范式验证**

只需验证F中的函数依赖关系

- 如果α是一个超码，利用属性闭包来验证每个依赖α$\to$β
- 如果α不是一个超码，必须验证β中每一个属性是否包含在R的候选码中

第三范式验证是NP-hard问题



**3NF分解算法**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/3NF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95.png)

第三范式分解满足无损分解，且保持依赖



**设计目标**

对应用函数依赖进行数据库设计的目标有：

- BCNF
- 无损
- 保持依赖

然而，这三个要求有时不能同时达到，经常导致以下结果之一

- 缺乏保持依赖
- 使用3NF造成冗余





### 多值依赖

**多值依赖(MVDs)**

令R为一关系模式，并令$\alpha \subseteq R$且$\beta \subseteq R$ 
$$
\alpha \to \to \beta
$$
在R上成立的条件是，在关系R的合法实例r中，对于r中任意一对满足t1[α]=t2[α]的元组对t1和t2，r中都存在元组t3和t4，使得：
$$
t1[α]=t2[α]=t3[α]=t4[α]
$$

$$
t3[β]=t1[β]
$$

$$
t3[R-β]=t2[R-β]
$$

$$
t4[β]=t2[β]
$$

$$
t4[R-β]=t1[R-β]
$$

性质

- 多值依赖具有对称性

$$
若X\to \to Y,则X\to \to Z,其中Z=U-X-Y
$$

- 函数依赖是多值依赖的特例
- 平凡的多值依赖

**MVDs理论**

又多值依赖的定义，我们可以得出以下规则，对于$\alpha$,$\beta \subseteq R$

- 若$\alpha \to \beta$,则$\alpha \to \to \beta$
- 每一个函数依赖也是一个多值依赖



D的闭包$D^+$是由D逻辑蕴含的所有函数依赖和多值依赖的集合



**Armstrong公理**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/Armstrong%20%E5%85%AC%E7%90%86.png)



**多值依赖 vs 函数依赖**

区别

函数依赖规定某些元组不能出现在关系中，也成为相等产生依赖

多值依赖要求某种形式的其他元组必须在关系中，称为元组产生依赖



有效性范围

多值依赖的有效性与属性集范围有关，属性集范围变小可以，变大不一定行

函数依赖的有效性仅取决于X、Y属性集上的值，和它在什么属性集上无关



**第四范式**

函数依赖和多值依赖为D的关系模式R属于第四范式的条件是，对于$D^+$中所有形若$α\to \to \beta$的多值依赖，至少有以下之一成立:

- $\alpha \to \to \beta$是一个平凡的多值依赖
- $\alpha$是R的一个超码



$4NF\subseteq BCNF$



**多值依赖的限定**

函数依赖和多值依赖的集合D，D在$R_i$上的限定是集合$D_i$，它包含

- $D_+$中所有只含$R_i$中的函数依赖
- 所有形如$\alpha \to \to (\beta ∩ R_i)$的多值依赖，其中$\alpha \subseteq \beta$属于$D^+$



**4NF分解算法**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/4NF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95.png)

### 数据库设计过程

谨慎定义E-R图，正确的识别所有的实体，由E-R图生成的关系模式应该就不需要太多进一步的规范化



**为了性能去规范化**

为了性能，可能使用没有规范化的模式



**其他设计问题**

数据库设计中有一些方面不能用规范化描述

不好的数据库设计应该避免





### 时态数据建模

`时态数据`:具有关联的时间段的数据，在时间段之间数据有效

`快照`:表示一个特定时间点上该数据的值

`时态函数依赖`: X->Y在关系模式R上成立的条件是，对于R的所有合法实例，r的所有快照都满足函数依赖

实践中，通常将起始和终止时间作为属性，为关系添加有效时间

### 规范化小结

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%A7%84%E8%8C%83%E5%8C%96%E5%B0%8F%E7%BB%93.png)

## 数据存储和数据访问

### 物理存储介质概述(了解)

几种有代表性的介质：

- 高速缓冲存储器Cache 高速缓冲存储器是最快最昂贵的存储介质
- 主存储器main memory 用于存放可处理的数据的存储介质 
- 快闪存储器flash memory 断电或故障时数据可以保存下来
- 磁盘存储器 magnetic-disk storage 长期联机数据存储的主要介质时磁盘，通常整个数据库都存储在磁盘上
- 光学存储器
- 磁带存储器 主要用于备份数据和归档数据



最快的存储器(Cache，主存储器) 称为基本存储

磁盘，快闪存储器称为辅助存储或联机存储

光盘，磁带 称为三级存储或脱机存储



为了保护数据，必须将数据写到非易失性存储中



### 磁盘(了解)

#### 物理特性

**读写头**

- 接近盘片表面，对磁化的信息进行读或写

盘片的表面划分为磁道

每个磁道又划分为扇区（扇区是读写数据的最小单元，大小一般为512字节）



**读/写一个扇区**

- 磁臂将读写头移动到正确的磁道
- 磁头从旋转的盘片中读/写数据



**磁盘集合**

- 一个轴上有几个盘片 (通常是1到5个)
- 每一个盘片有一个读写头, 所有读写头都在一个磁盘臂上



柱面 i 包含所有盘面上第i个磁道



**磁盘控制器**

计算机系统和实际的磁盘驱动器硬件之间的接口

- 接受高层次的读/写扇区的命令

- 开始动作，如移动磁盘臂到正确的磁道，并实际地读写数据

- 为确保读取数据的正确性，为每块扇区计算和附加校验和

- 在写扇区后，通过重读扇区确保写入成功

- 对坏的扇区重新映射



#### 磁盘性能的度量

磁盘质量的主要度量指标是容量、访问时间、数据传输率和可靠性

**访问时间**

从发出读写请求到数据开始传输之间的时间

- 寻道时间

  磁盘臂重定位时间,随着磁盘臂移动距离增大而增大

- 旋转等待时间

​	等待访问的扇区出现在读写头之下所花费的时间



**平均寻道时间** 寻道时间的平均值,约为最长寻道时间的1/2



**数据传输率**

从磁盘获得数据或向磁盘存储数据的速率



最大传输率是每秒 25 到100 MB, 内侧磁道数据传输率较低



多个磁盘共享一个控制器，所以控制器可以处理的速度，也很重要



**平均故障时间**

预计磁盘连续无故障运行的平均时间



#### 磁盘块访问的优化

**块**-包含固定数目的连续扇区

- 数据在磁盘和主存之间交换以块为单位
- 块的大小在512字节到几KB之间
  - 块太小需要交换多次，太大空闲空间造成浪费



磁盘臂调度算法决定块的访问顺序，使磁盘臂移动距离最短

通常使用电梯算法



**文件组织**

为了减少块访问时间，我们可以按照与预期的数据访问方式最接近的方式来组织磁盘上的块

如：在同一/相近柱面存储相关信息

问题:一段时间后文件可能变得碎片化

空闲的块是分散的, 新创建的文件的块可能是分散的顺序访问这些碎片化文件可能导致磁盘臂移动距离的增长

一些系统提供减少碎片的功能以提高文件访问速度



**非易失性的写缓冲区**

通过将块立即写到非易失性RAM上来提高磁盘写的效率

当磁盘上没有其他请求时或请求在等待期间，控制器将缓冲区中数据写到磁盘上

那些需要在数据被安全写回后才能继续的数据库操作可以继续执行而不必等数据被写回磁盘

写的顺序可以重新组织从而使磁盘臂的移动距离最短



**日志磁盘**

 一种专门用于写顺序日志的磁盘

对日志磁盘的所有访问都是顺序的，从根本上消除了寻道时间，并且一次可以写连续的块



文件系统通常对写入磁盘的操作重新排序以提高性能

日志文件系统 数据的写入是安全的

在无日志情况下重排序: 可能会使文件系统数据损坏



**快闪存储**

NOR 快闪 vs NAND 快闪

NAND 快闪 

广泛地用于存储，因为比NOR快闪便宜得多

固态硬盘:使用多个闪存存储设备从而提供更高的数据传输速率



### 文件组织

- 一个数据库被映射到多个不同的文件，这些文件由底层的操作系统来维护

- 一个文件在逻辑上组织成为记录的一个序列，这些记录映射到磁盘块上

- 一个记录是多个字段的序列



在文件处理和数据库管理中，一个“记录”通常是一个完整的、独立的数据单元。它代表一个实体（如一个人、一个订单、一个事件等）的所有相关信息。记录通常包含多个字段，每个字段存储该实体的一个属性或特征。



- 要求每条记录包含在单个块中



一种实现方式：记录定长，每个文件只有一种特定类型的记录，不同的文件被用于不同的关系



#### 定长记录

将记录顺序存放在文件中

- 在一个块中只分配它能完整容纳下的最大的记录数(每个块余下的字节就不使用)

- 删除记录时，将紧跟其后的记录移动到被删记录先前占据的空间
  - 简单地将最后一条记录移动到被删记录所占据空间更容易
  - 在文件开始处，分配一定数量的字节作为文件头，在文件头中维护被删除的第一个记录的地址，并用第一个记录存储第二个可用记录的地址，被删除的记录形成了一条链表，经常称为`空闲列表`



#### 变长记录

存储在一个文件中的记录有多个记录类型

记录类型允许记录中某些字段值的长度可变

记录类型允许记录中可重复出现某一字段



变长属性的记录通常分为两个部分，首先是定长属性，接下来是变长属性，对于定长属性，直接分配所需的字节数，对于边长属性，在`记录初始部分`表示为一个对(偏移量，长度)值

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%BE%B9%E9%95%BF%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%A8%E7%A4%BA.png)

空位图表示哪个属性为空值



**分槽的页结构**用于在块中组织记录

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%88%86%E6%A7%BD%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84.png)

- 块头中记录条目的个数

- 块中空闲空间的末尾处

- 一个由包含记录位置和大小的记录条目组成的数组



实际记录从块的尾部开始连续排列

插入一条记录，在空闲空间的尾部给这条记录分配空间，并将包含这条记录大小和位置的条目添加到块头中

删除一条记录，它所占用的空间被示范，它的条目被设置成被删除状态，此外，块中在被删除记录之前的记录将被移动，使得由删除而产生的空闲空间被重用

空闲空间末尾指针也要做适当修改



### 文件中记录的组织

#### 顺序文件组织

适用于需要对整个文件进行顺序处理的应用程序

记录在搜索码上排序



为了快速地按搜索码地顺序获取记录，通过指针把记录链接起来

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87.png)

删除-用指针链

插入-找到记录将要被插入的位置

- 如果有空闲空间则插入
- 如果没有空闲空间，分配一个溢出块，插入
- 指针链必须更新

需要时堆文件进行重组以保持顺序



#### 多表聚簇文件组织

一种在每一块中存储两个或者更多个关系的相关记录的文件结构

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%A4%9A%E8%A1%A8%E8%81%9A%E7%B0%87%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87.png)

允许使用一次块的读操作来读取满足连接条件的记录

不利于单个表相关的查询

记录长度是可变的

对于一个确定的关系可以用指针链连接记录



### 数据字典存储

数据字典(系统目录）存储元数据

- 关系的有关信息
- 用户和账号信息，包括密码
- 统计和描述数据
- 文件的组织信息
- 索引信息

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%B3%BB%E7%BB%9F%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png)

专门的数据结构设计，用于在主存中高效存取

### 数据库缓冲区

数据库系统尽量减少磁盘和内存之间的数据块传输数量。可以在主存中保留尽可能多的块来减少磁盘访问次数

缓冲区：部分主存用于存储磁盘块的副本

缓冲区管理：负责在主存中分配缓冲区空间的子系统



**缓冲区管理**

当程序需要从磁盘中得到一个块时，调用缓冲区管理程序

- 若块在缓冲区中，则缓冲区管理程序返回块在主存中的地址
- 若块不在缓冲区中，缓冲区管理程序
  - 为这个块在缓冲区中分配空间，若缓冲区满了，则替换某些块，替换的块需要写回磁盘
  - 将这个块从磁盘中读到缓冲区中，并将这个主存中的地址返回给请求者



**缓冲区替换策略**

LRU策略，替换最近最少使用的块





查询已经时定义良好的访问模式（顺序扫描），数据库可以使用用户查询的信息来预测未来的访问





`被钉住的块`不允许写回磁盘的块



**立即丢弃策略**

一但一个块的最后一个元组处理完毕，缓冲区管理器释放这个块所占用的空间



**最近最常使用策略**MRN

系统必须把当前正在处理的块钉住。在块中最后一个元组处理完毕后，这个块就不再被钉住，成为最近最常使用的块



缓冲区管理器可以使用有关一个请求将访问某个特定关系的概率的统计信息



缓冲区管理器也支持块的强制写出以支持数据库的恢复



### 索引基本概念

索引机制用于加快访问所需数据的速度



`搜索码`：用于在文件中查找记录的属性或属性集



索引文件由如下形式的记录(索引项)组成

| search-key | pointer |
| ---------- | ------- |



**索引评价指标**

- 能有效支持的访问类型
- 访问时间
- 插入时间
- 删除时间
- 空间开销



### 顺序索引

在一个顺序索引中，索引项按照搜索码值的排序顺序存储



`主索引`:包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为主索引

也被称为聚集索引

主索引常常是主码



`辅助索引`：搜索码指定的顺序与文件中记录的物理顺序不同的索引

非聚集索引



`索引顺序文件` 在搜索码上有聚集索引的文件



**稠密索引文件**

文件中的每个索引码值都有一个索引项

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png)

**稀疏索引文件**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%B3%BB%E6%95%B0%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png)

只为搜索码的某些值建立索引，只有索引是聚集索引时才能使用稀疏索引

为了定位一个搜索码值为K的记录

1. 找到搜索码值小于K的最大索引项
2. 从该索引项所指记录开始，沿着文件中的指针查找，直到找到所需记录为止



优点：所占空间较小，插入和删除时所需的维护开销也较小

缺点：定位一条记录时，通常比稠密索引更慢



**折中处理:** 为文件中的每个块建一个索引项的系数索引是一个很好的折中



**多级索引**

如果主索引不能放在主存中，访问效率将会变低

将主索引当作一个连续的文件保存在磁盘上，创建一个它之上的稀疏索引

如果外层索引还是太大而无法放在内存中，可以再创建一个次级索引，以此类推

对文件进行插入或删除操作时，各级索引必须全部更新

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png)

**辅助索引**

索引记录指向一个包含所有特定搜索码值的实际记录的指针的桶

辅助索引必须是稠密索引

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png)

想要找到属性值在某个满足一定条件的域(不是主索引的搜索码域）内的所有记录

**主索引和辅助索引**

索引为记录检索提供了巨大便利

索引更新的开销被强加于数据库更新之上，一个文件更改，文件上的每一个索引都必须被更新

按主索引顺序对文件进行顺序扫描是非常有效的，但使用辅助索引进行顺序扫描是很费时的



**索引更新：插入**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%B4%A2%E5%BC%95%E6%9B%B4%E6%96%B0%20%E6%8F%92%E5%85%A5.png)

**索引更新：删除**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%88%A0%E9%99%A4.png)



### $B^+$树索引文件

优点：

- 在数据插入和删除时，能够通过小的自动调整来保持平衡

- 不需要重组文件来维持性能

缺点：

- 增加文件插入和删除的时间开销，同时会增加空间开销



#### $B^+$树的概念

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/B+%E6%A0%91.png)

结点结构

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/B+%E6%A0%91%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png)

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%8F%B6%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png)

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%9D%9E%E5%8F%B6%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png)

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/B+%E6%A0%91%E6%80%A7%E8%83%BD.png)

B+树查询

```
C=root
While(C不是叶子结点)
{
i<-最小的满足V<=Ki
如果不存在 则C指向C中最后一个不为空的指针
如果存在，且V=Ki，则C=Pi+1 ，V<Ki 则C=Pi
}
i 为 最后的满足Ki=V
如果存在，根据Pi找到记录
如果不存在，则不存在搜索值为V的记录
```



#### **处理重复**

对于重复的搜索码

叶节点和内部结点中
$$
K_1\le K_2\le ... \le K_{n-1}
$$
Pi指针所指向的子树的搜索码一定是$\le$Ki的

要理解为什么是这样。假设同样的搜索码值 V  存在于两个叶结点 Li 和 Li+1 中，则父结点 Ki 就必须等于 V



更改查找程序 置 C = C.Pi  即使 V = C.Ki

而且由此达到的叶结点 C 可能仅包含小于 V 的搜索码（即使 V 在树中并不存在）

在这种情况下，查找过程必须置 C = C 的右兄弟，并且在此检查 C 是否包含 V 



#### **B+树插入/删除 **

插入：顶点分裂



删除

- 找到要删除的记录，从主文件和桶（如果存在）中移除它
- 如果没有桶或者桶为空，则从叶结点中移除索引项
- 如果因为移除而使结点内的项太少，并且结点可以和兄弟结点的项进行合并，合并兄弟结点:
  - 将两个结点的搜索码值插入同一个结点 (左边的结点)，删除另一个结点
  - 若 Pi 是指向被删结点的指针，从该结点父结点删除对(Ki–1, Pi)，递归的使用上面的过程

- 如果因为移除而使结点内的项太少，但是兄弟结点的项的数目不适合与它合并为一个单一结点，重新分配指针:
  - 重新分配该结点与兄弟结点的指针使得所有结点都包含最少数目的项
  - 更新父结点中相应的搜索码和指针

- 结点的更新向上递归直到一个包含 n/2(向上取整) 或更多指针的结点被发现

- 如果更新过后根结点只剩一个指针，它将被删除，并且它的孩子结点成为新的根结点





#### 不唯一的搜索码

- 在单独的块中建立桶
- 建立指针列表
  - 使用额外的代码来处理长列表，重复的搜索码过多会导致删除列表元组的开销很大
  - 低的空间开销，对于查询不需要额外开销

- 创建包含原始搜索码和其他属性的复合搜索码来确保搜索码唯一
  - 存储码值时产生额外开销
  - 插入/删除代码简单
  - 最广泛的应用



#### B+树文件组织

解决索引文件退化问题

解决数据文件退化问题

用B+树文件组织的叶结点存储记录，而不是使用指针

叶结点仍然需要半满

- 由于记录比指针大, 存储在叶结点中的记录的最大数目是小于存储在非叶结点的指针数目的

插入和删除方法与B+树索引相同



### 散列文件组织和散列索引

#### 散列

`桶`表示能能存储一条或多条记录的一个存储单位，通常一个桶就是一个磁盘块

在`散列文件组织`中可以直接从搜索码使用`散列函数`得到包含记录的桶

散列函数 h 是一个从所有搜索码值的集合 K 映射到桶地址的集合 B 的函数

散列函数用来定位要访问，插入或删除的记录

带有不同搜索码值的记录可以映射到同一个桶中，因此，为了找到一个记录，桶要被依次检索

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87.png)

#### `散列函数`

最糟糕的散列函数映射所有搜索码值到同一个桶

理想的散列函数是`均匀`的

把存储的码均匀地分布到所有桶中，使每个桶含有相同数目的记录

理想的散列函数是`随机`的

搜索码值实际怎么分布，每个桶应分配到的搜索码值数目几乎相同

通常散列函数在搜索码中字符的内部二进制机器表示上执行计算



#### 桶溢出处理

**原因**

- 桶不足
- 偏斜

`偏斜`

某些桶分配到的记录比其他桶多，所以即使其他桶仍有空间，某个桶也仍可能溢出

why? 多条记录可能具有相同的搜索码,所选的散列函数可能会造成搜索码的分布不均



`溢出链`

一个给定桶的所有溢出桶用一个链接列表链接在一起

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%BA%A2%E5%87%BA%E9%93%BE.png)



#### 散列索引

`散列索引`将搜索码及其相应的指针组织成散列文件结构

严格的说散列索引只是一种辅助索引结构

- 如果一个文件自身是按散列组织的，就不必在其上另外建立一个独立的索引结构
- 使用散列索引来表示散列文件结构，同时也用它表示辅助散列索引



**静态散列的不足**

静态散列技术要求固定桶地址集合 B ，但是大多数数据库都会随时间而变大，这会带来很严重的问题

如果初始桶的数目太小，随着文件的增长，由于产生太多溢出，导致性能下降(如果预期增长的空间提前被分配，大量空间将被浪费掉,如果数据库收缩，空间将会被再次浪费)



解决方案：周期性对散列结构进行重组（规模大，耗时）

更好的解决方案：允许桶的数量动态修改



#### 动态散列

允许散列函数动态改变

`可扩充散列`一种动态散列

散列函数产生的值范围相对较大，是 b 位二进制整数

定义了一个前缀，前缀长度为i (0~32)

- 桶地址表大小$2^i$ 
- i随着数据库大小变化而增大或减小

不同的桶地址目录可能会指向同一个桶

实际的桶数<$2^i$



顺序索引和散列的比较



## 查询处理和查询优化

### 概述

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E7%9A%84%E6%AD%A5%E9%AA%A4.png)



查询处理的基本步骤：

1. 语法分析和翻译

- 把查询语句翻译成系统的内部表示形式(关系代数)
- 语法分析器检查语法，验证关系

2. 查询优化

- 在所有等效执行计划中选择具有最小执行代价的计划
- 使用来自数据库目录的统计信息来评估代价

3. 执行

- 查询执行引擎接收一个查询执行计划，执行该计划并把结果返回给查询



### 查询代价的度量

查询处理的代价可以通过查询对各种资源的使用情况进行度量，如：

- 磁盘存取
- 执行一个查询的CPU时间
- 网络通信代价

等等



通常以`磁盘上存取数据的代价`作为主要代价，

- 搜索磁盘次数(平均寻道时间) 
- 读取的块数(平均块读取时间)
- 写入的块数(平均块写入时间)

写入一个块的代价通常大于块读取的代价



只用`传输磁盘块数`以及`搜索磁盘次数`来度量查询计算计划的代价

- $t_T$ -传输一个块的时间
- $t_S$-磁盘平均访问时间

忽略CPU时间，没有将操作的最终结果写回磁盘的代价



### 关系代数运算的执行

#### 选择运算

##### 使用文件扫描和索引的选择

**A1线性搜索**

系统扫描每一个文件块，对所有记录进行测试，看它们是否满足条件

(假设文件的磁盘块顺序存放)
$$
时间代价=b_r次磁盘块传输+1次磁盘搜索
$$
对于作用在码属性上的选择操作来说，系统在找到所需记录后可以立即停止
$$
时间代价=b_r/2次磁盘块传输+1次磁盘搜索
$$


`索引扫描`：使用索引的搜索算法，选择条件必须是索引的搜索码



**A2主索引，码属性等值比较**

对于具有主索引的码属性的等值比较，我们可以使用索引检索到满足相应等值条件的唯一一条记录
$$
cost=(h_i+1)*(t_T+t_S)
$$
索引查询穿越树的高度，再加上一次I/O来取记录，每一次I/O操作需要一次搜索和一次块传输



**A3主索引，非码属性等值比较**

假定块顺序存储,b代表包含具有指定搜索码值的记录的磁盘块数
$$
cost=h_i*(t_T+t_S)+b*t_T
$$


**A4辅助索引，等值比较**

- 码属性等值比较

$$
cost=(h_i+1)*(t_T+t_S)
$$

- 非码属性等值比较

最坏情况下，每个记录都在不同的磁盘块上,读出n个记录
$$
cost=(h_i+n)*(t_T+t_S)
$$
如果需要检索大量记录，最坏情形开销可能会比线性搜索还大





涉及比较的选择，可以使用线性搜索，也可以按照以下方法之一来实现选择



**A5 主索引，比较**
$$
cost=h_i*(t_T+t_S)+b*t_T
$$


**A6 辅助索引，比较**

对于$σ_{A\ge V}(r)$，使用索引找到第一个$\ge$v的索引项，从这里开始依次扫描索引，找到指向记录的指针

对于$σ_{A\le V}(r)$,扫描索引的叶子页来找到指针，直到找到第一个>v的索引项

每个记录需要一个I/O，线性扫描代价可能更小



#### 连接运算

**嵌套循环连接**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/1%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png)

r：外层关系 s:内层关系



最坏情况下，缓冲区只能容纳每个关系的一个数据块，连接代价为

- $n_r*b_s+b_r$次块传输
- $n_r+b_r$次磁盘搜索

最好情况下，较小的关系可以放入内存中，使用它为内层关系

- $b_r+b_s$次块传输
- 2次磁盘搜索

**块嵌套循环连接**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/2%E5%9D%97%E5%B5%8C%E5%A5%97%E8%BF%9E%E6%8E%A5.png)

最坏代价:

- $b_r*b_s+b_r$次块传输
- $2*b_r$次磁盘搜索

最好情况：

- $b_s+b_r$次块传输
- 2次磁盘搜索



**索引查找法**

索引查找法可以代替文件扫描法，若

- 连接是自然连接或等值连接
- 内层关系的连接属性上存在索引(可以为了计算连接建立临时索引)

对于外层关系的每个元组$t_r$,可以利用索引查找满足连接条件的s中的元组



最坏情况下，缓冲区只能容纳r的一块和索引的一块,对于外层关系r的每一个元组，对关系s进行索引查找



连接的时间代价为
$$
b_r(t_T+t_S)+n_r*c
$$
c是使用连接条件对关系s进行单次选择操作的代价

当r和s都有索引时，将元组较少的关系作为外关系时效果更好



**归并连接**

在连接属性s上对所有关系进行排序(如果之前并非有序)

连接它们，归并有序关系(具体的过程看课本)



可用于计算自然连接和等值连接，每个块只需读取一次

归并连接的代价：

- $b_r+b_s$次块传输

- 为每个关系分配$b_b$个缓冲块，需要$b_r/b_b(向上取整)+b_s/b_b(向上取整)$次磁盘搜索
- 排序代价



**混合归并-连接**

如果一个关系已排序，另一个关系具有一个连接属性上的B+树辅助索引

- 把已排序关系和另一个关系的B+树辅助索引叶结点进行归并
- 按照未排序关系元组的地址进行排序，按照物理存储顺序检索元组
- 从而能够对相关元组按照物理存储顺序进行有效的搜索，完成连接操作

顺序扫描比随机查找更有效



**散列连接**

适用于等值连接和自然连接

假设：

- h是将JoinAttrs值映射到{0,1,...,$n_h$}的散列函数
- $r_0,r_1,...r_{n_{h}}$表示关系r的划分，每个元组$t_r\in r$都被放入划分$r_i$中，其中i=$h(t_r[JoinAttrs])$

- 对于关系s，与关系r上面的处理相同

如果关系r的一个元组与关系s的一个元组满足连接条件，那么它们在连接属性上就会有相同的值

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%95%A3%E5%88%97%E8%BF%9E%E6%8E%A5.png)

关系s称为`构造用输入关系` 关系r称为`探查用输入关系`



`递归划分`

如果$n_h$的值大于或等于内存块数M，因为没有足够缓冲块，所以划分不能一趟完成，完成关系的划分需要重复多趟

每一趟中，输入的最大划分不超过用于输出的缓冲块数目

每一趟产生的存储桶在下一趟中分别被读入并再次划分，产生更小的划分

每次划分采用与上一次不同的散列函数

系统不断重复输入的分裂过程直到构造用输入关系的每个划分都能被内存容纳为止



`散列连接的代价`

不需要递归划分

磁盘块传输次数：

- 两个关系r，s的划分需要对着两个关系分别进行一次完整的读入和写回,$2(b_r+b_s)$次块传输
- 在构造和探查阶段，每个划分读入一次，需要($b_s+b_r$)次块传输，

- 划分所占用的块数可能比$b_r+b_s$略多，因为有的块只是部分满的，$n_k$个划分就可能有$n_k$个部分满的块，这个块需要写回，读入各一次

$$
块传输次数=2(b_r+b_s)+(b_r+b_s)+4n_h
$$

磁盘搜索次数:

- 假设为输入和输出缓冲区分配了$b_b$个块,划分需要2($b_r/b_b(向上取整)+b_s/b_b(向上取整))$

- 每个划分需要一次磁盘搜索 

$$
磁盘搜索次数=2(b_r/b_b(向上取整)+b_s/b_b(向上取整))+2n_h
$$



递归划分

磁盘块传输次数

每趟可将划分的大小减小到原来的1/(M-1),不断重复操作直到划分最多占M块为止，划分关系s所需的趟数预计

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%AC%E5%BC%8F1.png)

选择较小的关系作为构造关系

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%80%92%E5%BD%92%E5%88%92%E5%88%86%E7%A3%81%E7%9B%98%E5%9D%97%E4%BC%A0%E8%BE%93%E6%AC%A1%E6%95%B0.png)

当内存中可以容纳整个构造用输入关系时，可以不必将关系划分为临时文件了，估计代价为$b_r+b_s$次磁盘块传输和两次磁盘搜索



### 表达式计算

#### 物化

每次计算的结果被**物化**到一个临时关系中以备后用，临时关系必须写道磁盘上

**物化计算**：从最底层开始，执行树中的运算，计算每个中间结果，然后用于下一层

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%89%A9%E5%8C%96.png)

将结果写入磁盘和读取它们的代价非常大

总体代价=单个运算代价的总和+将中间结果写入磁盘的代价



**双缓冲技术** 使用两个缓冲区，其中一个用于连续执行算法，另一个用于写出结果



#### 流水线

流水线上同时计算多个运算，一个运算的结果传递给下一个，不必保存临时关系

- 流水线有时不可行(排序，散列连接)

- 对于有效流水线，当作为输入的元组被接收时，立即使用计算算法得到输出元组



**流水线执行方法**

- 需求驱动或消极计算

系统不断地向位于流水线顶端的操作发出需要元组的请求。为了输出自己的下一个元组，每个操作发出请求以获得来自子操作的下一个元组

迭代算子维护两次调用之间的执行“状态”，使得下一个next()调用请求可以获取下面的结果元组

- 生产者驱动或积极流水线

各操作并不等待元组请求，而是积极地产生元组

在两个操作之间创建一个缓冲区，子操作将元组放入缓冲区，父操作从缓冲区中提取元组并移除它

如果缓冲区已满，子操作将一直等待，直到缓冲区产生足够的空间此时该子操作将产生更多元组，直到缓冲区再次满为止

只有当一个输出缓冲区已满，或一个输入缓冲区已空，需要更多的输入元组来产生输出元组时，系统才需要在各操作之间切换



流水线的`推`和`拉`模式



### 查询优化

一个查询的不同执行计划的代价差异时巨大的

基于代价的优化的步骤

- 使用等价规则产生逻辑上的等价表达式
- 注解结果表达式来得到代替查询计划
- 基于代价估计选择代价最小的计划

计划代价的估计基于：

- 关系的统计信息
- 用于中间结果的统计估计
- 算法的代价公式，使用统计来计算



#### 等价规则

合取选择运算可以被分解为单个选择运算的序列
$$
σ_{\theta_1\and \theta_2}(E)=σ_{\theta_1}(σ_{\theta_2}(E))
$$


选择运算满足交换律
$$
σ_{\theta_1}(σ_{\theta_2}(E))=σ_{\theta_2}(σ_{\theta_1}(E))
$$


一系列投影只有最后一个运算是必须的，其余的省略



选择操作可以与笛卡尔积以及θ连接相结合
$$
σ_{\theta}(E_1XE_2)=E_1\Join_\theta E_2\\
σ_{\theta_1}(E_1\Join_{\theta_2} E_2)=E_1\Join_{\theta_1\and \theta_2} E_2\\
$$


θ连接运算满足交换律
$$
E_1\Join_\theta E_2=E_2\Join_\theta E_1
$$


自然连接运算满足结合律



θ连接具有以下方式的结合律
$$
(E_1\Join_{\theta_1}E2)\Join_{\theta_2\and\theta_3}E_3=E_1\Join_{\theta_1\and\theta_3}(E2\Join_{\theta_2}E_3)\\
\theta_2只涉及E_2和E_3的属性
$$


选择运算在下面两个条件下对θ连接具有分配律

1. 当选择条件θ0的所有属性只涉及参与连接运算的表达式之一时

$$
σ_{\theta_0}(E_1\Join_{\theta} E_2)=(σ_{\theta_0}(E_1))\Join_{\theta}E_2
$$

2. 当选择条件θ1只涉及E1的属性，选择条件θ2只涉及E2属性时

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%AC%E5%BC%8F2.png)



投影运算在下列条件下对θ连接具有分配律

1. θ只涉及L1∪L2中的属性

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%AC%E5%BC%8F3.png)

2. 

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%85%AC%E5%BC%8F4.png)



集合的并和交满足交换律，集合差不满足交换律



集合的并与交满足结合律



选择运算对∩，∪，-运算满足分配律



投影运算对并运算具有分配律



#### 转换的例子

下推选择-尽可能早地执行选择操作，减小被连接的关系的大小

下推投影

连接的次序，先连接较小的关系



### 代价估计

#### 表达式结果集统计大小的估计

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%9B%AE%E5%BD%95.png)

**选择运算结果大小的估计**

$σ_{A=v}(r)$

满足选择的记录数:n_r/V(A,r)

一个关键属性上的等价条件，规模估计=1



$σ_{A\le V}(r)$ 大于等于的情况是对称的

c表示满足条件的元组的估计值

- v<min(A,r) 则c=0

- v>=max(A,r)则c=$n_r$

- 否则
  $$
  c=n_r\frac{v-min(A,r)}{max(A,r)-min(A,r)}
  $$

存在直方图，可以得到更精确的估计

不存在统计信息时，c被假设为$n_r/2$



**复杂选择运算结果的大小估计**

条件$\theta_i$的`选中率`时关系r上一个元组满足$\theta_i$的概率
$$
\theta_i=s_i/n_r
$$
合取:
$$
σ_{\theta_1\and\theta_2\and...\and \theta_n}(r)
$$
大小
$$
n_r\frac{s_1*s_2*...*s_n}{n_r^n}
$$
析取：
$$
n_r(1-(1-\frac{s_1}{n_r})*(1-\frac{s_2}{n_r})*...*(1-\frac{s_n}{n_r}))
$$
取反：总的减掉满足的即可



**连接运算结果的大小估计**

笛卡尔积rxs包含$n_r·n_s$个元组，每个元组占用$s_r+s_s$个字节



`自然连接`

若关系R和S没有共同属性，则连接结果的规模与笛卡尔积一样

若R∩S是R的码，则可知s的一个元组至多与r的一个元组相连，连接后的元组数目不会超过s中元组的数目

若R∩S构成了S中参照R的外码，$r\Join s$中的元组数正好与s中的元组数相等



若R∩S={A}既不是R的码，也不是S的码，假设R中的所有元组在$R\Join S$中产生的元组个数估计为
$$
\frac{n_r*n_s}{V(A,s)}
$$

$$
\frac{n_r*n_s}{V(A,r)}
$$

取最小值



### 执行计划选择

当选择执行计划时，必须考虑执行技术的相互作用

为每个操作独立地选择代价最小的算法可能不会产生最佳的整体算法

- 归并连接可能比散列连接代价更大，但可以提供一个排序的输出，从而降低外层聚合的代价
- 嵌套循环连接可以为使用流水线技术提供机会



实际的查询优化器合并了以下两种方法的元素

- 搜索所有计划，基于代价选择最佳的计划
- 使用启发式方法选择计划



#### 基于代价的优化

考虑连接
$$
r_1\Join r_2 \Join...\Join r_n
$$
寻找最佳连接顺序

how？ 不必产生所有连接顺序，使用动态规划，{r1,...,rn}任意子集的代价最小的连接顺序只计算一次，存储起来，以备将来使用



**左深连接树** 

左深连接树种，每个连接右手侧的输入是一个已存储的关系,而不是一个中间连接的结果

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%B7%A6%E6%B7%B1%E8%BF%9E%E6%8E%A5%E6%A0%91.png)

**代价优化**

使用动态规划优化稠密树的时间复杂度是$O(3^n)$，空间复杂度是$O(2^n)$

为有n个关系的一组关系找到最好的左深连接树



如果只有左深树被考虑，找到最佳连接顺序的时间复杂度是O(n2^n)

空间复杂度仍是O(2^n) 需要存储2^n种连接情况



基于代价的优化是昂贵的，但对于大型数据库上的查询时值得的



#### 启发式优化

基于代价的优化的缺点是优化本身的代价

查询优化器使用启发式方法来减少优化代价

启发式优化通过一系列规则转化查询树，通常能改善执行性能

- 尽早执行选择运算
- 尽早执行投影运算
- 在其他类似运算之前，执行能对关系进行最大限制的选择和投影运算



**查询优化器的结构**

许多优化器只考虑左深连接顺序

- 使用启发式规则在查询树下对选择和投影进行下推
- 减少优化的复杂性，适合生成流水线执行的计划

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96.png)



## 事务管理

### 事务概念

`事务`(transaction) 是访问并可能更新各种数据项的一个程序执行单元



**事务的ACID特性**

- 原子性(atomicity)
- 一致性(consistency)
- 隔离性(isolation)
- 持久性(durability)



原子性：事物的所有操作再数据库中要么全部正确反映出来，要么完全不反应



一致性：隔离执行事务时（没有其他事务并发执行的情况下）保持数据库的一致性



隔离性：多个事务可能并发执行，但系统保证，对于任何一对事务Ti和Tj。在Ti看来，Tj或者在Ti开始之前已经完成执行，或者在Ti完成之后才开始执行。==每个事务都感觉不到系统中有其他事务在并发执行==



持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障



### 事务状态图

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E5%9B%BE.png)

事务处于终止状态时，系统有两种选择：

- 重启事务(事务终止是由于硬件错误或者不是由事务内部逻辑产生的软件错误)
- 杀死事务(由于事务的内部逻辑错误引起，重写应用程序)



### 事物的隔离性

**为什么事务要并发执行？**

如果多个事务在系统中串行执行，则无需考虑隔离性

并发执行有两个优势：

- 提高吞吐量和资源利用率
- 减少等待时间



**并发控制机制**-保证隔离性的一系列机制

控制事务之间的交互，以防止它们破坏数据库的一致性



**调度(Schedule)** 指令在系统中执行的顺序

- 一组事务的一个调度，包含这组事务的全部指令
- 必须保持指令在各个事务中出现的顺序

一次事务的执行成功地完成后，会有一条提交指令作为最后一条语句

一次事务地执行没有成功完成，会有一条中止指令作为最后一条语句



**并发操作带来的数据不一致性**

- 丢失修改
- 不可重复读
- 读"脏"数据



丢失修改：两个事务T1,T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失



不可重复读：事务T1读取数据后，事务T2执行更新操作，T1无法再现前一次读取结果

- T1读取某一数据后，T2对其做了修改
- T1读取某一数据后，T2删除了其中部分记录
- T1读取某一数据后，T2插入了一些记录

后两种情况有时称为`幻影`现象



读"脏"数据:

事务T1修改某一数据，并将其写回磁盘

事务T2读取同一数据，T1由于某种原因撤销

T1已修改过的数据恢复原值，T2独到的数据就与数据库中的数据不一致

T2读到的数据就为”脏“数据，即不正确的数据



**正确的调度**

数据不一致性：并发操作破坏了事务的隔离性

并发控制就是要用正确的方式调度并发操作，使得一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性



### 可串行化

假设每个事务都能保证数据库的一致性，进而一组事务的连续执行可以保证数据库的一致性

如果一个(可能并发的)调度等价于一个串行调度，则该调度是可串行化的。

等价调度的形式：

- 冲突可串行化
- 视图可串行化



**事务的简化形式**

忽略read和write指令之外的所有操作

事务可以对驻留在事务局部缓冲区中的数据执行任意读写操作

调度简化为只包含read和write两条指令



**冲突指令**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%86%B2%E7%AA%81%E6%8C%87%E4%BB%A4.png)

如果调度中的连续指令没有冲突，那么即使它们在调度中互换位置，结果仍然一样



**冲突可串行化**

如果通过一系列非冲突指令的交换，调度S可以转换为调度S'，则S和S‘是`冲突等价`的

调度S是冲突可串行化的，如果它与一个串行调度冲突等价



### 事务的隔离性与原子性

考虑事务故障在并发执行过程中

可恢复的调度-如果事务Tj读取了Ti缩写的数据项，则Ti先于Tj提交



级联回滚--单个事务失败，导致一系列事务回滚



无级联调度-不会发生级联回滚

对每一个事务对Ti和Tj，如果Tj读取了Ti所写的数据项，Ti必须在Tj的读操作之前提交



### SQL中的事务定义

数据操作语言必须指定一组动作，来包含对事务的操作

SQL中，事务是隐式开启的

SQL中的事务结束时，通过：

- 提交操作 提供当前事务并开始一个新事务
- 回滚操作 引起当前事务的终止

在大多数数据库系统中，每条SQL语句默认都在执行成功后隐式地提交



### 并发控制

数据库必须提供一个机制，确保所有可能的调度

- 冲突可串行化，视图可串行化
- 可恢复的，最好是无级联的



**较弱级别的一致性**

一些应用愿意接受弱一致性，允许调度不是可串行化的

- 可串行化-默认
- 可重复读

只允许读取已提交数据，两次读取数据之间不允许其他事务更新这些数据项。

- 已提交读

只允许读取已提交数据，不要求可重复读

- 未提交读

允许读取未提交数据



### 基于锁的协议

锁式控制对数据项的并发访问的机制

数据项枷锁具有两种锁模式

- exclusive(X) 模式，数据项即可以读又可以写 用lock-X指令申请
- Shared(S)模式 数据项是只读的，使用lock-S指令申请



要求每个事务都要根据自己将对数据项Q进行的操作类型申请适当的锁，将请求发送给并发控制管理器

事务只有在并发控制管理器授予所需锁后才能继续其操作

**锁相容矩阵**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%94%81%E7%9B%B8%E5%AE%B9%E7%9F%A9%E9%98%B5.png)

如果请求的锁与其他事务在该数据项上已经持有的锁相容，事务可以被授予该数据项上的锁

如果没有被授予锁，申请锁的事务需要等待，直到其他事务锁持有的所有不相容的锁都已释放，锁才会授予



**锁协议的不足**

1. 会导致死锁

为处理死锁，必须进行事务回滚，释放锁

2. 饥饿

要防止饥饿，可以对申请S锁的事务，如果有先于该事务且等待的加X锁的事务，令申请S锁的事务等待。

### 两阶段封锁协议

保证可串行性的一个协议是两阶段封锁协议。协议要求每个事务分两个阶段提出加锁和解锁申请

1. 增长阶段：事务可以获得锁，不可以释放锁
2. 缩减阶段：事务可以释放锁，不可以获得新锁

**封锁点**：在调度中，该事务获得其最后枷锁的位置，也是增长阶段的结束点。记作Lp(T)

并行执行的所有事务均遵守两段锁协议，则对这些事务的所有并行调度策略**都是可串行化**的



**两阶段封锁协议不能确保避免死锁**

可能产生级联回滚，如何解决？

==严格两阶段封锁协议== 事务必须持有所有排他锁，直到事务提交或中止

==强两阶段封锁协议== 事务提交或中之前，不能释放任何锁，在该协议中，事务按照提交的顺序可串行化



**两阶段封锁协议可以保证冲突可串行化**



### 死锁处理

如果事务集中的每个事务在等待该集合中的另一个事务，则系统处于死锁状态

==死锁预防==协议确保系统不会进入死锁状态

- 要求每个事务在执行前封锁所有的数据项（预声明）
- 给所有数据项施加偏序关系，要求事务按照偏序关系封锁数据项（基于图的协议)维护成本⾼



#### **利用时间戳来预防死锁**

- wait-die模式

老事务可以等待年轻事务释放数据项，年轻事务不等待老事务，而是直接回滚

在获取所需的数据项前，事务可能会死若干次

- wound-wait模式

老事务不等待年轻事务，直接强制其回滚，年轻事务等待老事务

老事务比新事务有更高的优先级，避免了饥饿



#### **基于超时的策略**

事务等待封锁一段时间，超时之后事务回滚

死锁不会发生，容易实现，但是可能产生饥饿。超时时间难以确定



#### **死锁检测**

用等待图表示事务之间的等待关系，系统处于死锁状态，当且仅当等待图存在环

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%AD%89%E5%BE%85%E5%9B%BE.png)



#### **死锁解除**

发现死锁时

一些事务必须回滚来去除死锁，选择成本最小的那些事务作为牺牲品

回滚

- 完全回滚：中止事务，重启动
- 部分回滚：回滚到解除死锁位置，这种方法更有效

如果同一事务总是被牺牲，进而导致饥饿，把回滚次数作为成本因子，避免饥饿



### 多粒度

#### 概念

允许数据项有不同的大小，定义数据粒度层次，小粒度数据项嵌套在大粒度数据项中，可以图形化表示为一棵树

当事务在树种显示封锁一个结点，它隐式地封锁了该节点地所有层次

封锁的粒度:

- 细粒度：高并发度，高封锁负载
- 粗粒度：低封锁负载，低并发度

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E7%B2%92%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%9B%BE.png)

树中每个结点都可以单独枷锁，当事务给一个结点枷锁，该事务也以同样类型的锁隐式地封锁这个结点地全部后代结点



问题：给高层节点加锁时，如何知道低层结点是否已经加锁？

1. 从加锁节点遍历所有子节点（违背了多粒度封锁机制的初衷）
2. **意向锁**

当一个事务希望在树的某个子结点（比如文件或记录）上加锁时，它首先在其所有祖先结点上设置意向锁。意向锁表明该事务的意图，但并不阻止其他事务访问那些结点。

当另一个事务希望加锁某个结点时（比如根结点），它只需检查该结点和其所有祖先结点上的锁。如果它发现任何与其请求不兼容的锁（包括意向锁），那么它就知道自己的加锁请求会被拒绝，而无需搜索整棵树。



#### **意向锁模式**

- 共享型意向锁(IS) 意味着树的较低层次进行显式封锁，但只能加共享锁
- 排他型意向锁(IX) 意味着树的较低层次进行显式封锁，加共享锁或排他锁
- 共享排他型意向锁(SIX) 以该节点为根的子树被显式的加共享锁并且将在树的较低层显式的加排他锁

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%84%8F%E5%90%91%E9%94%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%AE%B9%E7%9F%A9%E9%98%B5.png)



#### **多粒度封锁协议**

采用这些锁类型可保证可串行性：每个事务Ti按如下规则对数据项Q进行加锁

1. 事务Ti必须遵从锁类型相容函数
2. 事务Ti必须首先封锁树的根节点，并且可以加任意类型的锁
3. 仅当Ti当前对Q的父节点具有IX或IS锁时，Ti才能对结点Q可加S或IS锁
4. 仅当Ti当前对Q的父节点具有IX或SIX锁时，Ti对结点Q可加X、SIX、IX锁
5. 仅当Ti未曾对任何结点解锁时，Ti可对结点加锁
6. 仅当Ti当前不持有Q的子节点的锁时，Ti可对结点Q解锁

多粒度协议要求加锁按自定向下的顺序、锁的释放按自底向上顺序



多粒度封锁协议使用场合：

只访问几个数据项的短事务

由整个文件或者一组文件生成报表的长事务



### 基于时间戳的协议

#### **时间戳**

数据库系统在事务Ti开始前赋予它一个唯一的固定的时间戳，记作TS(Ti)

两种简单的方法：

- 使用系统时钟作为时间戳
- 使用逻辑计数器，每赋予一个时间戳，计数器增加计数

每个数据项Q需要与两个时间戳值相关联

- W-timestamp(Q): 成功执行write(Q)的所有事务的最大时间戳
- R-timestamp(Q)：成功执行read(Q)的所有事务的最大时间戳

每当有新的read(Q)或write(Q)指令执行时，这些时间戳就更新



#### **时间戳排序协议**

保证任何有冲突的read和write操作按时间戳顺序执行：

假设事务Ti发出read(Q)

1. 若TS(Ti)<W-timestamp(Q)，则Ti需要读入的Q值已经被覆盖，read操作被拒绝
2. 若TS(Ti)$\ge$W-timestamp(Q),则执行read操作，R-timestamp(Q)被设置为R-timestamp(Q)和TS(Ti)的最大值

假设事务Ti发出write(Q)

1. 若TS(Ti)<R-timestamp(Q)，则Ti产生的Q值时先前所需要的值，并且系统假定该值不会再产生。因此 write操作被拒绝，Ti回滚
2. 若TS(Ti)<W-timestamp(Q)，则Ti视图写入的Q值已经过时，write操作被拒绝，Ti回滚
3. 其他情况，执行write操作，更新W-timestamp值为TS(Ti)



**协议分析**

时间戳排序协议保证冲突可串行化，这因为冲突操作按时间戳顺序进行处理

协议保证无死锁，因为不存在等待的事务

当一系列短事务引起长事务反复重启时，可能导致长事务饿死的现象。如何解决？

发现一个事务反复重启，与之冲突的事务应当暂时阻塞，以使该事务能够完成



该协议可能导致级联回滚，并且甚至可能不可恢复

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%A7%E4%B8%8E%E9%81%BF%E5%85%8D%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A.png)



#### Thomas写规则

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/thomas%E5%86%99%E8%A7%84%E5%88%99.png)

Thomas规则允许更多的潜在并发性，它允许做某些非冲突可串行化的视图可串行化调度



### 基于有效性检查的协议

有效性检查协议要求每个事务Ti在其声明周期中按两个或三个阶段执行

1. 读阶段

系统执行事务Ti。各数据项值被读入并保存在事务Ti的局部变量中。所有write操作都是对局部临时变量进行的，并不对数据库进行真正的更新。

2. 有效性检查阶段

对事务Ti进行有效性测试(下面将会介绍)。判定是否可以执行 write 操作而不违反可串行性。如果事务有效性测试失败，则系统终止这个事务

3. 写阶段

如果事务Ti通过有效性检查阶段，则保存Ti任何写操作结果的临时局部变量值被复制到数据库中，只读事务忽略这个阶段



并发执行的多个事务的三个阶段可以交叉，但是每个事务必须按顺序通过三个阶段



**事务的三个时间戳**

Start(Ti)：事务Ti开始执行的时间

Validation(Ti)：事务Ti完成读阶段并开始有效性检查的时间

Finish(Ti)：事务完成写阶段的时间



为了增加并发性，可串行化次序由有效性检查时的时间戳次序决定

TS(Ti)被赋予Validation(Ti)的值

如果冲突的概率很小，本协议很有用，能带来更大程序的并发性



**事务Tj的有效性检查**

对于所有满足TS(Ti)<TS(Tj)的Ti，下列任一条件成立:

1. finish(Ti)<start(Ti)
2. start(Tj)<finish(Ti)<validation(Tj)并且Ti缩写的数据项集合与Tj所读的数据项集合不相交

- Tj的写不影响Ti的读
- Ti的写不影响Tj的读



### 恢复系统

**故障分类**

- 事务故障：
  - 逻辑错误：因为某些内部错误条件导致事务不能完成
  - 系统错误：因为某种错误条件(比如死锁)导致数据库系统终止一个活跃事务
- 系统崩溃：停电故障或者其他软硬件故障导致系统崩溃
  - 故障-停止假设：非已失性存储器的内容不会因系统崩溃而破坏
    - 数据库系统通过很多完整性检查来防止磁盘数据被破坏
- 磁盘故障：磁头损坏或类似的磁盘故障可能破坏全部或部分磁盘存储器
  - 假设损坏可以检测到，磁盘驱动器使用校验和来检测故障



#### 数据访问

磁盘和主存之间的块移动通过下列两个操作引发：

- input(B) 将物理块B传入主存
- output(B) 将缓冲块B传到磁盘，并且替换相应的物理块

为了简单起见，我们假设每个数据项都能存入并且确实存储在单个块中



每个事务Ti都有自己的私有工作区，用来保存它存取和更新的所有数据项的局部副本(Ti对应于数据项X的局部副本记为xi)

事务通过以下操作在系统缓冲块和它的私有工作区之间传送数据项:

- read(X) 将数据项X的值赋给局部变量xi
- write(X)将局部变量xi的值赋给缓冲块中的数据项{X}



事务第一次访问X时执行read(X) 后续读操作是对局部副本进行的

最后一次访问后执行wirte(X)

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE.png)

#### 恢复与原子性

为了在故障的情况下仍确保原子性，我们首先向稳定存储器输出描述更新的信息，而不更新数据库本身



#### 基于日志的恢复

**日志**保存在稳定存储器上，是**日志记录**的序列，用来记录对数据库的更新活动

当事务Ti启动，写入一条登记自己的日志记录

```sql
<Ti start>
```

Ti 执行write(X) 前，写入日志记录<Ti,X,V1,V2> 

V1,V2为X的旧值和新值

当Ti完成了最后一条语句，写入日志记录

```sql
<Ti commit>
```



**立即数据库修改**

立即修改计数允许在事务提交之前，对还未提交的事务进行更新

更新的日志记录必须在数据库数据修改之前写入稳定存储器

被更新块的输出可能发生在事务提交之前或之后的任何时刻

块输出的次序可以与修改块的次序不同



**延迟修改**技术 只有在事务提交时才执行更新



**事务提交**

当一个事务的commit日志记录输出到稳定存储器后，我们就说这个事务提交了

包含该事务修改的数据块可以在以后的某个时间再输出到稳定存储器



#### 并发控制与恢复

对于并发的事务，所有事务共享单个磁盘缓冲区和单个日志



假设：如果事务Ti修改了数据项，那么Ti提交或撤销之前，不允许其他事务来修改数据项

- 未提交的事务所做的更新对其他事务是不可见的
- 可以通过对更新的数据获得排他锁，并且持有该锁知道植物提交来保证(严格的两阶段锁)

不同事物的日志记录再日志中可能交错分布



**Undo和Redo操作**

对于日志记录<Ti,X,V1,V2>

- Undo 将X写为旧值V1
- Redo 将X写为新值V2

事务的Undo和Redo

undo(Ti) 将事务Ti更新过的所有数据项的值都恢复成旧值，从Ti的最后一条日志记录向前进行

- 每次数据项X恢复到它的旧值V，就写下一个特殊日志<Ti,X,V>
- 当事务undo操作完成后，写下一个日志记录<Ti abort>
- redo(Ti) 将Ti更新过的所有数据项的值都设置成新值，从Ti的第一条日志记录向后进行，不产生新日志



**崩溃恢复中的Undo和Redo**

当从系统崩溃中恢复时：

- 对事务Ti进行撤销，如果日志
  - 包括<Ti start>记录
  - 不包含<Ti commit>或<Ti abort>记录
- 需要对事务Ti进行重做，如果日志
  - 包括<Ti start>记录
  - 包括<Ti commit>或<Ti abort>记录

重复所有原始的动作，包括恢复旧值得动作(被称为重复历史)

看似浪费资源，实际上大大简化了恢复



#### 检查点

重做/撤销日志中记录得所有事务会非常慢

why？ 系统运行很长时间，处理全部日志非常耗时，并且我们不需要重做已经输出了对数据库的更新的事务

how? 定期执行检查点实现流水恢复

1. 将当前位于主存的所有日志记录输出到稳定存储器
2. 将多有修改的缓冲块输出到磁盘
3. 将一个日志记录<checkpoint L>输出到稳定存储器，其中L是执行检查点时正活跃的事务的列表

检查点执行过程中，不允许事务执行任何更新活动



系统崩溃发生之后，系统检查日志以找到最后一条<checkpoint L>记录，对L中的事务，以及<checkpoint L>记录写到日志之后才开始执行的事务进行undo或者redo操作
