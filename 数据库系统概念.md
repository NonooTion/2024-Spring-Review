# 数据库系统概念考前复习

## 引言

### 四个基本概念

**数据Data**

数据库中存储的基本对象

- 定义：描述事物的符号记录
- 种类：文字、图形、图像、声音
- 特点：数据与其语义不可分



数据结构

逻辑结构：数据之间存在的逻辑关系

物理结构：数据在计算机内的存储方式



**数据库DataBase**

长期存储在计算机内、有组织的、可共享的大量数据集合

- 数据按一定的数据模型组织、描述、存储
- 为各种用户共享
- 冗余度较小
- 数据独立性高
- 易扩展



**数据库管理系统 DBMS**

由一个相互关联的数据的集合和一组用以访问这些数据的程序组成

位于用户与操作系统之间的一层数据管理软件

主要功能:

- 数据定义功能 

提供数据库定义语言DDL,定义数据库中的数据对象

- 数据操纵功能

提供数据操作语言DML,操纵数据实现对数据库的基本操作(查询、插入、删除、修改)

- 数据库的运行管理

保证多用户对数据的并发使用；数据的安全性、完整性；保证故障后的系统恢复

- 数据库的建立和维护功能

数据库数据批量装载,数据库转储...

**数据库系统**

在计算机系统中引入数据库后的系统



构成：

- 数据库
- 数据库管理系统
- 应用系统及其开发工具
- 数据库管理员
- 用户



### 数据管理技术的发展

**数据管理**

对数据进行分类、组织、编码、存储、检索和维护

**数据管理的发展阶段**

人工管理阶段，文件系统阶段，数据库系统阶段，大数据阶段



**数据库系统阶段**

数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象

特点：

- 数据由DBMS统一存取，维护数据语义及结构
- 面向全组织，面向现实世界
- 独立性较强
- 数据统一按表结构存放



### 数据模型--数据库结构的基础

**数据模型描述**：

- 数据
- 数据关系
- 数据语义
- 数据约束



**常用数据模型**：

- `关系模型`

- `实体-联系数据模型`  主要用于数据库设计

- 半结构化数据模型 XML JSON
- 基于对象的数据模型
- 早期的数据模型
  - 网状模型
  - 层次模型



**实例和模式**

型和值的区别

型是对数据的结构和属性的说明(模式)

值是型的一个具体赋值(实例)

型是相对稳定的，值是随时间不断变化的



**数据抽象**

`模式`

数据库的总体设计

- 物理模式：在物理层描述的数据库设计
- 逻辑模式：在逻辑层描述的数据库设计
- 子模式/外模式：在视图层描述的数据库设计，逻辑模式的子集

`实例`

特定时刻存储在数据库中的信息的集合



物理数据独立性：物理模式的改变不会影响逻辑模式

当物理模式改变时，修改模式/内模式映象，使外模式不变，从而应用程序可以保持不变

逻辑数据独立性

当模式改变时，修改外模式/模式映象，使外模式保持不变，从而应用程序可以保持不变



### 数据库语言

**DDL**

Data Definition Language 用于定义数据库模式以及其他特征的语言

- 数据库模式
- 完整性约束
- 断言
- 授权

**DML**

Data  Manipulation Language 操纵那些按照某种适当的数据模型组织起来的数据的语言

- 查询
- 更新(增、删、改)

分类：过程化和声明式(非过程化)

SQL：广泛使用的非过程话语言



### 数据库设计

数据库设计的主要内容式`数据库模式的实际`

设计过程：

- 用户需求获取
- 概念设计
- 逻辑设计
- 物理设计



### 数据库引擎

**存储管理器**

是一个程序模块，提供了数据库中存储的低层数据与应用程序以及向系统提交的查询之间的接口

任务：与文件管理器交互，对数据的有效的存储、查询和更新

部件：权限及完整性管理器、事务管理器、文件管理器、缓冲区管理器

**查询处理器**

DDL解释器：它解释DDL语句，并将这些定义记录在数据字典中

DML编译器：将查询语言中的DML语句翻译成为一个执行方案

查询执行引擎：执行由DML编译器产生的低级指令

**事务管理**

事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位

事务特性：原子性、持久性、一致性、隔离性



### 数据库和应用系统结构

**数据库体系结构**

- 集中式
- 客户/服务器式
- 并行（多处理器）
- 分布式



### 数据库管理员

对数据库系统进行集中控制的人称作数据库管理员

作用：

- 模式定义
- 存储结构及存取方式定义
- 模式及物理组织的修改
- 数据访问授权
- 日常维护



## 关系模型

### 关系数据结构

关系型数据库中，关系是一种单一的数据结构

数据的逻辑结构是一张二维表

二维表的列叫做属性，行叫做元组

**属性**

每个属性可能的取值范围(集合)叫做属性的`域`

属性的值通常是原子的，不可再分

空值null：一个特殊的值，表示未知或不存在



**关系的基本概念**

笛卡尔积
$$
D_1\times D_2\times ...\times D_n
$$
的自己叫做在域D1,D2,...,Dn上的关系，用R(D1,D2,...,Dn)表示

R：关系的名字

n：关系的度或目



**关系的性质**

- 关系是无序的(元组的顺序是无关紧要的)
- 列是同质的
- 不同的列来自同一域，每列必须有不同的属性名-
- 列的次序可以任意交换(有的数据库产品不行)

- 两个元组不能完全相同(很多关系数据库没有遵循)

- 每一分量都是不可再分的(1NF)



### 关系模式和实例

R=A1,A2,...,An 是一个关系模式 (A1,A2,...,An是属性)

关系模式的当前值称为实例，可用一个表指定

数据库由多个关系组成



### 码

码的作用：区分给定关系中的不同元组的方法

超码：一个或多个属性的集合，这些属性可以使我们在关系中唯一地标识一个元组

候选码：最小的超码称为候选码

主码：从一个关系的多个候选码中选定一个作为主码

外码：一个关系模式R1可能在它的属性中包含另一个关系模式R2的主码，这个属性称作在R1上参照R2的外码(R1,R2可以是同一个关系)

- 关系R1称为外码依赖的参照关系
- 关系R2称为外码的被参照关系



**关系模式的完整性约束**

`实体完整性`

关系的主码中的所有属性值不能为空值

`参照完整性`

如果关系R2的外部码Fk与关系R1的主码Pk相对应，则R2中的每一个元组的Fk值或者等于R1 中某个元组的Pk 值，或者为空值

`用户定义的完整性`

用户针对具体的应用环境定义的完整性约束条件



### 关系代数

关系代数是一种过程化语言

**六种基本运算符**

- 选择 σ
- 投影 Π
- 更名 ρ
- 并 ∪
- 集合差 -
- 笛卡尔积 X

关系代数的运算以一个或两个关系作为输入，产生一个新的关系作为结果



**选择运算**
$$
ρ_p(r)=\{t\in r~and~p(t)\}
$$
p是一个命题演算公式，由$\and\or\neg$把项连接起来构成

选择运算以行的角度进行运算



**投影**
$$
\Pi_{A1,A2,...,A_k}(r)
$$
Ai：属性名

结果由选择的k列组成，关系是集合，重复的元组从结果中删除

投影操作主要是从列的角度进行的运算

**并运算**
$$
r ∪s=\{t| t\in r ~or~t \in s\}
$$
r和s必须是同元的 (属性数目相同)

属性的域必须相容

**集合差**
$$
r -s=\{t| t\in r ~and~t \not\in s\}
$$
r和s必须是同元的 (属性数目相同)

属性的域必须相容



投影和并满足分配律

投影和差不满足分配律



**笛卡尔积**
$$
r \times s=\{(r1,r2,..,r_n,s_1,s_2,..s_m)|(r_1,r_2,...r_n)\in r~and~ (s_1,s_2,...,s_m)\in s\}
$$
如果关系r和s的属性有交集，必须使用更名运算



**更名运算**

允许通过更名来引用关系代数表达式的结果
$$
ρ_x(E)
$$
返回被更名为X的表达式E的结果

如果关系表达式E是n元的
$$
ρ_{x(A_1,...,A_n)}(E)
$$
返回被更名为X的表达式E的结果，并且属性被更名为A1,A2,...,An



**关系表达式嵌套**

关系代数中基本的表达式是：

- 数据库中的一个关系
- 一个常数关系



### 附加的关系代数运算

**集合交**
$$
r∩s=\{t|t\in r ~and~ t\in s\}
$$
r和s是同元的

r和s属性的域相容



$\theta$**连接**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%CE%98%E8%BF%9E%E6%8E%A5.png)

θ为算术比较符



**自然连接运算**
$$
r\Join s
$$
关系r和s分别是模式R和S的实例

则$r\Join s $是由如下方式得到的R∪S的关系:

- 对于r中的每个元组$t_r$和s中的每个元组$t_s$所组成的元组对
- 如果$t_r$和$t_s$在R∩S的属性上有相同的值，则在结果中加入一个元组t且
  - t在r上和$t_r$有相同的值
  - t在s上和$t_s$有相同的值

自然连接满足交换律和结合律



**赋值运算**

将查询结果赋值给一个临时的关系变量

**外连接**

外连接是连接运算的扩展，可以处理缺失的信息

计算连接，然后一个关系中失配的元组添加到结果中

使用空值(null)

- 左外连接
- 右外连接
- 全外连接



**空值**

元组的一些属性可以为空值，用null表示

含null的算数表达式结果为null

两个null看作同样的值



空值的比较运算中

除了永真式和矛盾式，其他结果都为unkown



**除运算**

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E9%99%A4%E6%B3%95%E5%AE%9A%E4%B9%89.png)

象集

关系R(X,Y),X,Y是属性组，x是X上的取值，定义x在R中的象集为
$$
Y_x=\{t[Y]|t\in R \and t[X]=x\}
$$
从R中选出在X上取值为x的元组，去掉X上的分量，只留Y上的分量



除运算也可以写为
$$
temp1\leftarrow \Pi_{R-S}(r)\\
temp2\leftarrow \Pi_{R-S}(temp1\times s)-\Pi_{R-S,S}(r)\}\\
result=temp1-temp2\\
$$
除操作是同时从行和列的角度进行运算的



### 扩展的关系代数运算

**广义投影**

广义投影运算通过允许在投影列表中使用算术函数来对投影进行扩展 
$$
\Pi_{F_1,F_2,...,F_n}(E)
$$
Fi是涉及常量以及E的模式中属性的算术表达式



**聚集函数和聚集运算**

聚集函数 输入值的一个汇集，将单一值作为结果返回

- avg 平均值
- min 最小值
- max 最大值
- sum 求和
- count 计数

聚集运算在关系代数中
$$
G_1,G_2,...,G_n γF_1(A_1),F_2(A_2),...,F_n(A_n)(E)
$$
E是任一关系代数表达式

- Gi是用于分组的一系列属性 可以为空
- Fi是一个聚集函数
- Ai是一个属性名



聚集的结果没有名称，可以用更名运算给他命名

为了方便，我们允许将更名作为聚集运算的一部分  as



**多重集关系代数**

纯关系代数删除所有重复

多重集关系代数保存重复，匹配SQL语义



## SQL

### 数据定义语言

SQL的数据定义语言DDL能够定义每个关系的信息，包括：

- 每个关系的模式
- 每个属性的值域
- 完整性约束
- 以后将要看到的一些信息，比如
  - 每个关系的索引集合
  - 每个关系的安全性和权限信息
  - 磁盘上每个关系的物理存储结构



#### **SQL中的基本类型**

- char(n). 固定长度的字符串，长度为n
- varchar(n). 可变长的字符串  最大长度n
- int 整数类型
- smallint 小整数类型
- numeric(p,d) 定点数，精度由用户指定，这个数有p位数字，其中d位数字在小数点右边
- real,double precision 浮点数与双精度浮点数，精度与机器相关
- float(n).浮点数，精度至少为n位



#### **创建表结构**

使用create table命令创建一个SQL关系表

```sql
create table r (A1 D1,A2 D2,...,An Dn , (integrity-constraint t1,...,integrity-constraint tk))
```

r：关系名

Ai：属性名

Di：属性Ai的域的类型

ti：完整性约束

- not null
- primary key (A1,...,An)
- foreign key(Am,...,An) references r

声明为主码的属性自动确保为not null



#### **删除和更改表结构**

**drop table**

```
drop table <表名> [RESTRICT | CASCADE]
```

RESTRICT：删除表是有限制的

删除的基本表不能被其他表的约束所引用，否则表不能被删除

CASCADE：删除该表是没有限制的

在删除基本表的同时，相关的依赖对象一起删除



```sql
delete from <表名>
```

删除表中内容，但是保留表



**alter table**

```sql
//属性A是关系r将要增加的属性，D是A的域
//对于关系r中的所有元组，在新增加的属性上的取值都为null
alter table r add A D

//删除属性
alter table r drop A

//修改已存在的表 r 中的列 A 的属性。可以改变列的数据类型、大小、约束等
alter table r modify A

//删除表中约束
alter table 表名 drop constraint 约束名
```



### SQL数据查询功能

#### 基本查询结构

SQL的数据操纵语言DML提供从数据库中查询信息；插入、删除、修改元组的能力

一个典型的sql查询形式为：

```sql
select A1,A2,..,An
from r1,r2,...,rm
where P
```

#### select 子句

相当于关系代数中的投影运算，用于列出查询结果中所需要的属性

select子句的<目标列表达式>可以为

- 算术表达式
- 字符串常量

- 函数
- 列别名

SQL中允许关系和查询结果中保留重复的元组，如果想去重，需要在select后使用关键字distinct

```sql
select distinct ...
from ...

//select all 显示指明不去重复

*表示所有属性
select * 
from ...

select 子句可包含算术表达式

select ID,name,salary/2
from instructor
```

#### where子句

相当于关系代数中的选择谓词，指定查询结果必须满足的条件

语法成分：

- 逻辑运算符
- 比较运算符
- between条件

判断表达式的值是否在某范围内



#### from子句

与关系代数中的笛卡尔积运算相对应

一般不直接使用，而是与where子句一起使用



#### 连接查询及执行过程

同时涉及多个表的查询称为连接查询

用来连接两个表的条件称为连接条件或连接谓词 

一般格式
$$
[<表名1>.]<列名1>  <比较运算符>  [<表名2>.]<列名2>\\
[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
$$
**连接字段**

连接谓词中的列名称，连接条件中的各连接字段类型必须是可比的，不必是相同的



**执行过程**

- 嵌套循环法
- 排序合并法
- 索引连接法



#### 自然连接

**natural join**

自然连接只考虑两个关系模式中都出现的属性上取值相同的元组对，并且相同属性的列只保留一个副本

```sql
select * from instructor natural join teachers
```

自然连接中的危险：有些属性具有相同的名称，但是它们实际的意义是不同的



#### 更名运算

SQL允许使用as子句对关系和属性进行更名运算

```sql
old-name as new-name
```

as 是可选的，可以省略(Oracle中必须省略)

```sql
instructor as T = instructor T
```



#### 字符串运算

**like操作符**

SQL通过字符串匹配运算符来支持字符串上的比较，使用like操作符来实现模式匹配.使用两个特殊字符(通配符)描述模式

- 百分号(%) 匹配任何字串
- 下划线(_) 匹配任何字符

like具有单向性

```sql
'济南市山大路' like '济南市%' ture
'济南市%' like '济南市山大路' false
```

转义字符\

字符串的值是大小写敏感的



SQL支持的串运算：

- 串联 ||
- 大小写转换
- 计算串长度，抽取字串



**SQL正则表达式**

- REGEXP_LIKE(匹配)
- REGEXP_INSTR(包含)
- REGEXP_REPALCE(替换)
- REGEXP_SUBSTR(提取)

```sql
Select * from table1
  where REGEXP_LIKE(SJHM, ‘^[1]{1}[35]{1}[[:digit:]]{9}$‘)
```

- ^代表开始
- $表示结束
- []内部为匹配范围
- {}里的内容表是个数，有几位



#### 排列元组的显示次序

只是显示次序排序，只能是sql的最后一个子句，只能出现目标列内的字段

ASC,DESC



#### 重复

对于存在重复元组的关系，SQL可以决定在结果中显示该元组的几个副本



#### 集合运算

集合运算 union,intersect,except

自动去重

如果要保留重复

union all,intersect all,except all



#### 空值

元组的一些属性可以为空值，用null表示



带有null的任何比较运算返回unkown

三值逻辑使用真值 unknown：

除了永真式和矛盾式，其他的公式结果全部为unknown

where 将unknown 作为false来处理



#### 聚集函数

聚集函数以一个值的集合为输出，返回单个值

- avg
- min
- max
- sum
- count

聚集函数默认作用于多重集，作用于集合 使用distinct

```sql
select count(distinct ID)
```

SQL返回关系，返回的关系有且只有一行

Select子句中出现聚集函数，不能同时出现非聚集的属性



**Group By 子句**

在关系的自己上运用聚集函数，得到一个新的关系



GROUP BY子句的作用对象是查询的中间结果表



使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和聚集函数,不能出现非聚集的非分组属性



having是对分组聚集的结果进行选择



**空值和聚集**

除了count(*) ，其他的聚集运算都忽略聚集属性上位空值的元组

如果集合只有空值,count运算值为0，其他运算返回空值



#### 嵌套子查询

一个子查询是一个嵌套在其他的查询中的select-from-where 表达式

子查询常用于对集合成员的资格、集合的比较、集合基数进行检查

**集合成员的资格(in)**

```sql
找出在2009年秋季和2010年春季同时开课的所有课程
select distinct course_id
from section
where semester = ’Fall’ and year= 2009 and  course_id  in
				(select course_id
                                 from section
                                 where semester = ’Spring’ and year= 2010)
 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程
select distinct course_id
from section
where semester = ’Fall’ and year= 2009 and  course_id  not in (select course_id
                                 from section
                                 where semester = ’Spring’ and year= 2010);

```

**集合的比较(some,all)**

```sql
找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高 
select name
from instructor
where salary > some (select salary
                                     from instructor
                                     where dept_name = ’Biology’);
                                     
 找出满足下面条件的所有教师的姓名，他们的工资值比Biology系每个教师的工资都高 
select name
from instructor
where salary > all (select salary
                                from instructor
                                where dept_name = ’Biology’);
也可以简化不写all
```



**空关系测试**

exists，not exist

exists结构测试子查询结果是否有元组，子查询非空时，返回true



in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为`相关子查询`

子查询的`相关变量`是指在子查询中使用的，但其值取决于外部查询（也就是主查询）中的变量



**sql中“全部”概念的处理**

- 超集

not  exists(X except Y)

- 全称量词

not exists(not exists)

- ÷

not in(not in)



**测试重复的元组**

unique结构测试一个子查询的结果中是否有重复的元组

not unique



#### from子句中的子查询

SQL允许在from子句中使用子查询表达式

```sql
找出系平均工资超过42000美元的那些系中教师的平均工资 
    select dept_name, avg_salary
    from (select dept_name, avg (salary) as avg_salary       
          from instructor        
          group by dept_name)
          where avg_salary > 42000;

```

Lateral 子句允许 from 子句中后面的部分 （在关键词 lateral 后面的）访问前面部分的相关变量 

```
 select name, salary, avg_salary
 from instructor I1, 
 lateral (select avg(salary) as avg_salary
 from instructor I2
 where I2.dept_name= I1.dept_name);
```

#### with子句

with子句提供了定义临时关系的方法，这个定义支队包含with子句的查询有效

```sql
找出具有最大预算值的系
with max_budget (value) as 
(select max(budget)
from department)
select budget
from department, max_budget
where department.budget = max_budget.value;

```



#### 标量子查询

标量子查询只返回包含单个属性的单个元组

如果子查询的结果返回多个元组，则会产生运行错误

```sql
select dept_name, 
(select count(*) 
 from instructor 
 where department.dept_name=instructor.dept_name)
 as num_instructors
 from department;
```



### 数据库的修改

#### 删除

从表中删除符合条件的元组，如果没有where语句，删除所有元组

```sql
delete from 表名 where 条件表达式
```

```sql
删除工资低于大学平均工资的教师记录
delete from instructor
where salary<(select avg(salary) from instructor)
```



#### 插入

插入一条指定好值的元组

```sql
insert into 表名 [列名,...]
values (值,...)
```

插入多条元组

```sql
insert into 表名 (列名,...)
(子查询)
```



**几种特殊用法**

```sql
向 student 关系中插入新元组，并将tot_creds 属性设置为null
 insert into student
 values (‘3003’, ‘Green’, ‘Finance’, null);

将instructor 关系中的所有元组插入到student 关系里，并将属性tol_credits设置为0
 insert into student
 select ID, name, dept_name, 0
 from   instructor

```



#### 更新

```sql
update 表名
set 操作
where 谓词
```



case语句

```sql
update instructor
set salary=case
when salary<=100000 then salary*1.05
else salary*1.03
end
```



也可以通过标量子查询来更新数据库



## 中级SQL

### 连接表达式

**连接关系**

连接操作作用于两个关系并返回一个关系作为结果

Join操作通常用作from子句中的子查询表达式



连接操作将两个关系作为输入，并返回一个关系作为结果 这些额外的操作通常用作from子句中的子查询表达式

 连接条件 – 规定了这两个关系中的哪些元组匹配，以及在连接结果中出现什么属性

 连接类型 – 规定了对每个关系中（基于连接条件）不与其他关系中的元组相匹配的元组怎样处理 



**连接类型**

- 内连接
- 左外连接
- 右外连接
- 全外连接

**连接条件**

natural

on <谓词>

using <A1,A2,...,An>



在表名后面加外连接操作符(*)或(+)指定非主体表

非主体表有一“万能”的虚行,该行全部由空值组成

虚行可以和主体表中所有不满足连接条件的元组进行连接



### 视图

#### 视图创建

使用create view命令定义视图,命令格式为

```sql
create view v as <query expression>
```

其中<query expression> 可以是任何合法的SQL表达式 v表示视图名 

一旦定义了一个视图，我们就可以用视图名指代该视图生成的虚关系 



**特点**

- 视图是一个虚表，从一个或几个基本表导出的关系
- 只存放视图的定义，不会出现数据冗余
- 基表的数据发生变化，视图中查询出的数据也随之改变
- 查询时，视图名可以出现在任何关系名可以出现的地方



与派生查询(with)不同的是

视图存储在DB数据字典中，是数据库模式的一部分

with定义的派生关系，仅在所属的SQL有效，不属于DB模式



视图与表

- 都是关系，可以在SQL中直接应用
- DB中存储表的模式定义和数据，而只存储视图的定义
- 视图数据在使用表时临时计算
- 物化视图时提高计算的一种手段



视图的作用：对外模式的支持，安全性，方便性



#### 使用其他视图定义视图



可以使用另一个其他视图来定义视图

如果一个视图v2用于定义另一个视图v1的表达式，则称v1直接依赖于v2

如果一个视图关系v1 直接依赖于另一个视图关系v2，或通过其他视图间接依赖于v2，则称v1 依赖于v2

一个视图关系如果依赖于它自身，则被称为递归的 



#### 视图更新

通过update、delete等语句的使用，可以实现视图更新

所有对视图的更新，都会转化为对基础表的更新



**有些更新不能被单独执行**

大部分SQL实现只允许在简单试图上的更新

- from子句中只有一个数据库关系
- select子句中只包含关系的属性名，不包含任何表达式、聚集函数或distinct声明
- 任何没有出现在select子句中的属性可以取空值
- 查询中不包含groupby或having子句



**with check option**

视图定义时，指定with check option，强制通过视图进行的修改，结果必须在视图中（更新后的元组必须满足视图的定义，否则更新会被DBMS拒绝）



#### 物化视图

创建一个物理表，包含了视图查询结果的所有元组



why?

- 提高查询性能，空间换时间
- 物化视图对应用透明
- 基表发生变化，物化视图也应当刷新
- 规模较大的报表适合使用物化视图来提高查询性能



### 事务

事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位

事务具有

- 原子性

事务中包含的所有操作，要么全做，要么全不做

- 持久性

事务一旦提交，对数据库的影响必须是永久的

- 一致性

事务的隔离执行必须保证数据库的一致性

- 隔离性

系统必须保证事务不受其他并发执行事务的影响



事务以commit work 或 rollback work结束



大多数数据库默认每个SQL语句自动提交



### 完整性约束

**单个关系上的约束**

- not null
- primary key

主码值不允许为空，也不允许重复

- unique

声明一个候选码,候选码属性可以为空，不能重复

- check (P),P是谓词

只有对表的更新操作会触发check子句



**参照完整性**

A是一个属性的集合，R和S是两个包含属性A关系，并且A是S的主码 如果对于每个在R中出现的A在S中也出现，则A被称为R的外码



**级联行为**

删除(修改)基本关系元组

- RESTRICT

只有当依赖关系中没有一个外码值与要删除(修改)的基本关系的主码值相对应时，才能删除该元组

- CASCADE

将依赖关系中所有外码值与基本关系中要删除(修改)的主码值所对应的元组一起删除(修改)

- SET NULL

删除基本关系中元组时，将依赖关系中与基本关系中被删(修改)主码值相对应的外码值置为空







声明

```sql
FOREIGN KEY (S#) REFERENCES S(S#)  [ON DELETE [CASCADE | SET NULL] ]
```



### SQL的数据类型与模式

#### SQL固有的数据类型

- date：日期包括年(四位)、月、日

date '2005-6-24'

- time 时间

time '09:00:30'

- timestamp 

timestamp  ‘2005-7-27 09:00:30.75’

- interval 时间段

interval  ‘1’ day

两个 date/time/timestamp 类型值相减产生一个interval 类型值

可以在 date/time/timestamp 类型的值上加减interval 类型的值



**默认值**

可以为属性指定默认值

```sql
sex char(1) default '1'
```



**创建索引**

```sql
create index index_name on 表名(属性列)
```



**用户自定义类型**

```sql
create type type_name as 

create type Dollars as numeric(12,2) final

final:不能指定一个基于Dollars的新类型

结构化
create type person
(pid char(18)
name varchar(8));
```

进行强类型检查

**创建域**

```sql
create domain domain_name 

create domain degree_level varchar (10)
constraint degeree_level_test 
check (value in('Bachelors','Masters','Doctorate'))
```

不进行进行强类型检查，支持强制类型转换



#### 大对象类型

大对象以large object类型存储

blob:二进制数据的大对象数据类型

clob:字符数据的大对象数据类型



查询结果时指向这个大对象的指针，并非大对象本身



存储实现：指针+文件



LOB访问： 一般用专用语句访问

oracle 

```sql
SelectBlob  doc  into …
	from book
	where cno=‘c1’;
```

### 授权

**权限图**

结点是用户，根结点是DBA，有向边Ui→Uj，表示用户Ui把某权限授给用户Uj

一个用户拥有权限的充分必要条件是在权限图中有一条从根结点到该用户结点的路径



**授权形式**

Read - 允许读取，但是不能修改数据 

Insert - 允许插入新数据，但是不能修改已有数据 

Update - 允许修改，但是不能删除数据 

Delete - 允许删除数据 

Index - 允许创建和删除索引 

Resources - 允许创建新关系 

Alteration - 允许增加或删除关系的属性 

Drop - 允许删除关系 



all privileges 所有允许权限的简写形式

#### SQL授权规范

**grant语句**

```sql
grant 语句用于授予权限
		grant <权限列表>
		on <关系名或视图名> to <用户/角色列表>
```

<用户/角色列表> 是：

一个用户的id

public，所有合法用户持有所授权限

一个角色



对属性列的授权必须明确指出相应属性列名



应用程序的授权由应用程序本身完成，SQL授权机制被忽略



**收回授权**

```sql
revoke 语句用于收回授权
revoke <权限列表>
on <关系名或视图名> from <用户/角色列表>
```

<权限列表> 可以是 all ，表示收回被收回人持有的所有权限

如果<revokee-list> 包含public的话，则除了显式地被授予权限的用户外，所有的用户都将失去权限 

如果同一权限由不同的授权人两次授予同一用户，用户在一次权限被回收后，仍保持有权限 

收回权限时，若该用户已将权限授予其它用户，则也一并收回



**角色**

```sql
create role 角色名
```

角色可以被授以权限

角色可以授以用户，也可以被授以其他角色



**视图的授权**

视图的权限和基表的权限是分开管理的。

创建视图的用户必须具有基表的相应权限，而查询视图的用户只需要具有视图的权限

**其他授权特性**

references 权限 创造外码

with grant option子句，可以跟在grant语句最后，表明可以再授予权限，但要保证没有循环授权



## 高级SQL

### 使用程序设计语言访问数据库

动态SQL：允许运行时以字符串的形式构建SQL，提交查询

嵌入式SQL：必须再编译时全部确定，并交给预处理器



#### 动态SQL

##### **JDBC**

一个支持SQL的Java API，用于与数据库系统通信



JDBC支持查询、更新数据、检索查询结果等多种功能

也支持元数据检索



**JDBC与数据库的通信模型**

- 打开一个连接
- 创建一个"statement"对象
- 使用statement对象执行查询、发送查询并取回结果
- 处理错误的异常处理机制



JDBC的基本工作步骤

1. 加载JDBC driver class
2. 打开数据库连接
3. 执行SQL语句
4. 读取结果集合



**程序实例**

```java
try 
	{Class.forName(“oracle.jdbc.driver.oracledriver”);//定义驱动程序
	 Connection conn= DriverManager.getConnection
		("jdbc:oracle:thin:@202.194.7.x:1000:student", "u1","pw1");
	Statement stmt=conn.createStatement();//定义statement
	try{//插入s(s1,甲)
   stmt.executeUpdate("insert into s(sno,snane) values (‘s1’, ‘甲’ )");
   } 	catch (SQLException sqle)//错误处理
		{System.out.println(“could not insert:”+sqle);}
	try {//显示所有学生sno,sname
	    ResultSet rset=stmt.executeQuery("select sno,sname from s");
   	    while (rset.next())
	{
     System.out.println(rset.getString("sno")+":"+reset.getString("sname"));
    }
	    rset.close(); //释放rset
	   }
     catch (SQLException sqle)//错误处理
	{System.out.println(“select sno,sname err:” +sqle);}
	stmt.close();//释放statement
  	conn.close();//释放连接
	}
catch (SQLException sqle)
		{System.out.println(“SQLException:”+sqle);}

```



**JDBC 立即执行和预备语句**

立即执行：使用statement类，将sql语句交给DBMS执行，一次语句执行DBMS进行一次语句编译

预备语句执行：使用PreparedStatement类，sql语句执行，首先进行编译，编译结果赋予PreparedStatment的对象，预编译结果可被反复多次执行，JDBC预编译在程序运行中进行



预编译sql支持占位符"?" 相当于宿主变量，只是没有名字，使用数字表示第几个"?"

SQL执行前，要对占位符赋值

```java
PreparedStatement pStmt = conn.prepareStatement( "insert into instructor values(?,?,?,?)");
pStmt.setString(1, "88877");
pStmt.setString(2, "Perry");
pStmt.setString(3, "Finance");   
pStmt.setInt(4, 125000);
pStmt.executeUpdate();    
pStmt.setString(1, "88878");
pStmt.executeUpdate();

```

pStmt.executeQuery()，返回一个结果集（ResultSet）



当有用户的输入做参数时，最好使用预备语句(防止SQL注入攻击)



**元数据特性**

元数据：描述数据的数据



查询结果集元数据

执行完一个查询后，得到一个ResultSet rs

```java
ResultSetMetaData rsmd = rs.getMetaData();
     for(int i = 1; i <= rsmd.getColumnCount(); i++) {
           System.out.println(rsmd.getColumnName(i));
                  System.out.println(rsmd.getColumnTypeName(i));
	       }
```



数据库元数据

```java
DatabaseMetaData dbmd = conn.getMetaData();
	ResultSet rs = dbmd.getColumns(null, "univdb", "department", "%");
//getColumns的参数：Catalog，Schema模式，Table模式，
//和列模式
//返回：每列一行；行有许多属性
//例如COLUMN_NAME、TYPE_NAME
	while( rs.next()) {
	       System.out.println(rs.getString("COLUMN_NAME"),
                                                        rs.getString("TYPE_NAME");
     }

```

DataBaseMetaData

- JDBC类
- 对DB数据字典进行封装
- 类方法可以读取数据字典元数据
- 频闭了数据字典的具体实现模式
- 对应用提供访问DB数据字典元数据的标准方法

```sql
DataBaseMetaData dbmd;
	dbmd = conn.getMetaData();
	ResultSet rset; rset=dbmd.getColumns(null,"student","s","%") ;
	while (rset.next())  
		{rset.getString("COLUMN_NAME");
			//读取列名
		//rset.getString("COLUMN_TYPE");
			//读取列类型
		…}
	…

```



**JDBC事务控制**

默认情况下，每个SQL语句都被作为一个被自动提交的事务



可以关闭自动提交

```java
conn.setAutoCommit(false);

//显示提交或回滚
conn.commit();
conn.rollback();
```



**JDBC其他特征**

调用函数和过程：

```java
CallableStatement cStmt1 = conn.prepareCall("{? = call some function(?)}");
CallableStatement cStmt2 = conn.prepareCall("{call some procedure(?,?)}");
```

处理大型对象类型:

- getBlob 和 getClob方法返回Blob和Clob对象
- 通过getBytes()从这些对象里得到数据
- 通过一个开放的流与Java Blob或Clob对象相连，更新大对象

```java
blob.setBlob(int parameterIndex, InputStream inputStream).
```

JDBC过于动态化，错误无法被编译器捕捉



SQLJ：java中的嵌入式SQL



##### ODBC

Open DataBase Connectivity(ODBC) 

标准应用程序与数据库服务器通信的标准 

应用程序接口（API） 

- 与数据库建立一个连接

- 发送查询和更新数据库的语句

- 取回结果 



每个支持ODBC的数据库系统都提供一个与客户端程序相连接的“驱动程序”库 



当客户端程序发出ODBC API 请求后，库中的代码就与数据库服务器通信，执行被请求的动作，并取回结果 



ODBC 程序首先分配一个SQL环境变量，然后得到一个数据库连接句柄 



ODBC 使用SQLConnect( )打开和数据库的连接，SQL连接的参数：

- 连接句柄
- 要连接的服务器
- 用户标识符
- 密码

也必须指定arguments的类型：

SQL_NTS表示前一个参数是一个以null结尾的字符串 



```cpp
int ODBCexample()
	{
  RETCODE error; //用于存储 ODBC 函数的返回值，以检查是否有错误发生。
  HENV    env;   // ODBC 环境句柄
  HDBC    conn;  // ODBC 连接句柄
  SQLAllocEnv(&env); //分配一个 ODBC 环境句柄，并将其存储在 env 中
  SQLAllocConnect(env, &conn);//分配一个 ODBC 连接句柄，并将其存储在 conn 中。
  SQLConnect(conn, “db.yale.edu", SQL_NTS, "avi", SQL_NTS, "avipasswd", SQL_NTS); //连接到数据库
  { …. Do actual work … }
  SQLDisconnect(conn); //断开与数据库的连接
  SQLFreeConnect(conn); //释放连接句柄
  SQLFreeEnv(env); //释放环境句柄
}
句柄:句柄是一种标识符，用于标识和操作系统资源，如窗口、文件、数据库连接等;

```



序通过SQLExecDirect 发送 SQL 命令给数据库 

通过SQLFetch( ) 获取结果元组 

SQLBindCol() 将查询结果的属性值与C语言变量进行绑定  

```cpp
char deptname[80];
float salary;
int lenOut1, lenOut2;
HSTMT stmt;
char * sqlquery = "select dept_name, sum (salary)from instructor group by dept_name";
SQLAllocStmt(conn, &stmt);
error = SQLExecDirect(stmt, sqlquery, SQL_NTS);
    if (error == SQL_SUCCESS) {
        SQLBindCol(stmt, 1, SQL_C_CHAR, deptname , 80, &lenOut1);
        SQLBindCol(stmt, 2, SQL_C_FLOAT, &salary, 0 , &lenOut2);
        while (SQLFetch(stmt) == SQL_SUCCESS) {
            printf (" %s %g\n", deptname, salary);
        }
    }
SQLFreeStmt(stmt, SQL_DROP);

```



**ODBC预备语句**

SQL 语句准备：在数据库中先编译

采用占位符：如 insert into account values(?,?,?)

运行时将实际值传递给占位符，反复执行

```cpp
\\准备语句
SQLPrepare(stmt, <SQL String>);
\\绑定参数
SQLBindParameter(stmt, <parameter#>,  … type information and value omitted for simplicity..)
\\执行语句
retcode = SQLExecute( stmt);
```



**更多ODBC特性**

元数据特性

- 找出数据库中所有的关系
- 找出查询结果和数据库中关系的属性名和属性类型



**事务管理**

在默认情况下，每个SQL语句都被认为是一个自动提交的独立事务 

```cpp
//关闭连接的自动提交
SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0);
//事务提交或回滚
SQLTransact(conn, SQL_COMMIT);
SQLTransact(conn, SQL_ROLLBACK);
```



#### 嵌入式SQL

SQL 标准定义了许多语言的嵌入式SQL，如 C，Java和 Cobol

SQL 查询所嵌入的语言被称为宿主语言（host language），宿主语言中使用的SQL结构被称为嵌入式SQL



**EXEC SQL** 语句用于标识对预处理器的嵌入式SQL请求

```CPP
EXEC SQL <embedded SQL statement > END_EXEC
```

确切语法因循宿主语言的惯例



**预编译工作模式**

预编译将嵌入宿主语言的sql，编译成宿主语言的一段代码，执行这段代码，将完成相应sql调用执行



**预编译程序**

一般由DBMS供应商提供，如：oracle

提供的Pro*c有些数据库应用开发工具，将预编译程序与主程序编译器合为一体，如：PowerBuilder



##### 数据库连接

进行数据库访问必须基于数据库连接

```cpp
sqlca.servername="211.87.224.149"
sqlca.userid=…
sqlca.password=…
…
connect sqlca

撤销数据库连接
disconnect sqlca
```

**数据库连接建立与撤销的常用策略**

一般地，数据库连接可以在应用开始时完成

在应用结束时撤销数据库

连接应用执行过程中，可以保持数据库连接，以随时执行sql



##### SQLCA

SQL通讯域SQLCA是一结构

每一嵌入SQL语句的执行情况在其执行完成后写入SQLCA结构中的各变量中

根据SQLCA中的内容可以获得每一嵌入SQL语句执行后的信息,应用程序就可以做相应的处理



在数组语言中声明，是存储结构和函数的综合体

概念提出早于OO

![](image/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/sqlca.png)

APP必须对每一条sql的执行请看进行判定,How?

每条sql语句后，APP检查sqlca返回的执行报告

```cpp
select sname into :vname from s where …
if sqlca.sqlcode<>0 then
      报告错误，进行异常处理，必要时中止应用； 
end if 
```



##### 协调操作方式

why? SQL与主语言之间执行方式有差错

- SQL:一次一集合
- C：一次一记录

How? 若一个SQL语句返回多个元组 则使用游标



**主变量**

在SQL语句中使用的主语言程序变量简称为主变量

嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据



类型：输入主变量、输出主变量

输入、输出主变量可能是同一个主变量



指示变量：一个主变量可以附带一个指示变量



如何使用主变量和指示变量？

1. 声明主变量和指示变量

```
BEGIN DECLARE SECTION
	......... 
	.........     (说明主变量和指示变量)
	.........
END DECLARE SECTION

```

2. 使用主变量

说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现

为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志

3. 使用指示变量

指示变量前也必须加冒号标志,必须紧跟在所指主变量之后



在SQL语句以外的部分，可以直接引用主变量和指示变量，无需冒号



**查询结果为单记录的SELECT语句(无需游标)**

```
[例] 根据学生号码查询学生信息。假设已经把要查询的学生的学号赋给了主变量givensno
	EXEC SQL SELECT Sno，Sname，Ssex，Sage，Sdept        	          
		 INTO  :Hsno， :Hname ，:Hsex，:Hage，:Hdept
         FROM  Student
         WHERE Sno=:givensno；
```

INTO子句、WHERE子句和HAVING短语的条件表达式中均可以使用主变量

查询返回的记录中，可能某些列为空值NULL。

如果查询结果实际上并不是单条记录，而是多条记录，则程序出错，DBMS会在SQLCA中返回错误信息 

```cpp
EXEC SQL SELECT Sno，Cno，Grade                      
		    INTO :Hsno，:Hcno，:Hgrade:Gradeid   
						/*指示变量Gradeid*/
            FROM  SC
            WHERE Sno=:givensno AND Cno=:givencno；
如果Gradeid < 0，不论Hgrade为何值，均认为该学生成绩为空值。
```



**使用游标的SQL语句**

使用游标的过程

1. 说明游标

```
EXEC SQL DECLARE <游标名> CURSOR
            FOR <SELECT语句>;
```

2. 打开游标

```
EXEC SQL OPEN <游标名>;
打开游标实际上是执行相应的SELECT语句，把所有满足查询条件的记录从指定表取到缓冲区中
这时游标处于活动状态，指针指向查询结果集中第一条记录
```

3. 推进游标指针并取当前记录

```
 EXEC SQL FETCH [[NEXT|PRIOR|
                 FIRST|LAST] FROM] <游标名> 
  INTO <主变量>[<指示变量>][,<主变量>[<指示变量>]]...;
```

指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理

NEXT|PRIOR|FIRST|LAST：指定推动游标指针的方式 缺省为NEXT

4. 关闭游标

```
 EXEC SQL CLOSE <游标名>;
```

关闭游标，释放结果集占用的缓冲区及其他资源

游标被关闭后，就不再和原来的查询结果集相联系

被关闭的游标可以再次被打开，与新的查询结果相联系



**CURRENT形式的UPDATE语句和DELETE语句**

UPDATE语句和DELETE语句中的子句： 		

```
WHERE CURRENT OF <游标名>   
```

表示修改或删除的是最近一次取出的记录，即游标指针指向的记录 



**利用游标更新数据**

```cpp
//声明游标用于更新，来对游标获取的元组进行更新
declare c cursor for
select *
from instructor
where dept_name = ‘Music’
for update
//对游标c当前位置的元组进行更新
update instructor
set salary = salary + 100
where current of c
```

当游标定义中的SELECT语句带有UNION或ORDER BY子句 ,不能使用CURRENT形式的UPDATE语句和DELETE语句 

why？ 该select语句相当于定义了一个不可更新的视图



### 函数和过程化结构

**过程扩展和存储过程**

sql提供了一种模块语言

允许在SQL中使用if-then-else语句或while循环等定义过程



存储过程

可以在数据库里存储过程，然后再用call语句执行它们



#### SQL函数

定义函数，输入一个系的名字，返回该系教师的数量

```sql
create function dept_count(dept_name varchar(20))
return integer
begin
	declare d_count integer
	select count(*) into d_count
	from instructor
	where instructor.dept_name=dept_name
	return d_count
end
```

我们可以使用这个函数

找出教师数大于12的所有系的名称和预算 

```sql
select dept_name, budget
from department
where dept_count (dept_name ) > 12

```

**表函数**

返回关系作为结果的函数

返回一个包含特定系的所有教师的表

```sql
create function instructor_of(dept_name char(20))
return table(ID varchar(5),name varchar(20),dept_name varchar(20),salary numeric(8,2))

return table
(
    select ID,name,dept_name,salary
    from instructor
    where instructor.dept_name=instructors_of.dept_name
)
```

使用该表

```sql
select *
from table (instructors_of('Music'))
```



#### SQL过程

可以将SQL函数写成一个过程，在其他过程或者嵌入式SQL中使用call语句调用

```sql
create procedure dept_count_proc (in dept_name varchar(20), out d_count integer)
 begin
	  select count(*) into d_count
      from instructor
      where instructor.dept_name = dept_count_proc.dept_name
 end

declare d_count integer;
call dept_count_proc( ‘Physics’, d_count);

```



#### 过程化结构

复合语句 begin...end之间包含复杂的SQL语句

- 可以在复合语句中声明局部变量



while 和 repeat 语句

```sql
declare n integer default 0;
while n < 10 do
set n = n + 1
end while

repeat
set n = n  – 1
until n = 0
end repeat

```



For循环

允许对查询的所有结果重复执行

```sql
declare n  integer default 0;
for r  as
select budget from department
where dept_name = ‘Music’
do
set n = n - r.budget
end for
```



条件语句 if-then-else

确认选课的学生数没有超过该课所在教室的容量

返回0表示成功,返回-1表示容量超出





发信号通知异常条件，声明句柄来处理异常

```sql
declare out_of_classroom_seats condition
declare exit handler for out_of_classroom_seats
begin
…
..  signal out_of_classroom_seats
end

```



#### 外部语言函数/过程

SQL:1999 允许使用其他语言（如C 、 C++）编写的函数和过程

```sql
create procedure dept_count_proc(in dept_name varchar(20),out countinteger)
language C
external name ’ /usr/avi/bin/dept_count_proc’
                                 
```



优点：更强的表达能力

缺点：实现功能的代码可能需要加载到数据库系统并在数据库系统的地址空间中执行 有安全风险

如何保证安全性？

- 沙盒技术 使用一个安全的语言 如java
- 在一个单独的过程里运行外部语言函数/程序，不会对数据库进程的内存进行访问（进程间通信传递参数和结果）



### 触发器

`触发器`是一条语句，当对数据库做修改时，它自动被系统执行 

- 指明什么条件下执行触发器
- 指明触发器执行时的动作



#### 定义触发器

```sql
CREATE TRIGGER <触发器名>  
{BEFORE | AFTER} <触发事件> ON <表名>
FOR EACH  {ROW | STATEMENT}
［WHEN <触发条件>］
<触发动作体>

```

触发器类型:行级触发器（FOR EACH ROW）,语句级触发器（FOR EACH STATEMENT）

触发动作体

触发动作体可以是一个匿名PL/SQL过程块,也可以是对已创建存储过程的调用

**SQL里的触发事件和动作**

触发事件可以是insert，delete 或update

一个更新之前和之后的属性值可以被引用 

referencing old row as:  用于删除和更新

referencing new row as:  用于插入和更新 

触发器可以在一个事件（额外的约束）之前被激活

例如 把空白的成绩写为null

```sql
create trigger setnull_trigger before update of takes
referencing new row as nrow
for each row
when (nrow.grade = ‘ ‘)
begin atomic
set nrow.grade = null;
end;

```



**语句级触发器**

受一个事务影响的所有行可以执行一个单一的整体行动

而不是对每个受影响的行都单独执行行动 

用for each statement 子句代替for each row子句 

用referencing old table子句或referencing new table子句来指向包含所有被影响行的临时表（称为过渡表（ transition tables ）） 

在SQL语句更新大量的行时会更有效 



#### 激活触发器

触发器的执行，是由触发事件激活的，并由数据库服务器自动执行

一个数据表上可能定义了多个触发器，触发器的执行顺序

- 执行before触发器
- 激活触发器的sql语句
- 执行after触发器



#### 删除触发器

```sql
 DROP TRIGGER <触发器名> ON <表名>;
```



### 高级聚集特性

#### SQL递归

```sql
select * from …. where  [结果过滤条件语句]
start with  [and起始条件过滤语句]
connect by prior [and中间记录过滤条件语句] 
```



查询a的所有后代

```sql
select * from parent
start with parent='a'
connect by prior child = parent
```



#### 高级聚集-排名

排名是用order by语句来实现的

求每个学生的名次

```sql
select ID, rank() over (order by GPA desc) as s_rank
from student_grades
```

在拍名中可能会产生隔断，使用dense_rank不会产生隔断



排名可以在不同的区里进行

按系给学生排名

```sql
select ID, dept_name,
rank () over (partition by dept_name order by GPA desc) 
as dept_rank
from dept_grades
order by dept_name, dept_rank;
```

排名与group by子句/聚集同时出现的时候，group by子句/聚集首先执行，排名在其结果上执行 

其他排名函数

percent_rank （在分区完成的情况下，在分区内排名）

cume_dist （累积分布）元组的一部分与前面的值

row_number （可能存在重复）



对于一个给定的常数n，排名函数ntile(n)按照给定的顺序取得每个分区中的元组，并把它们分成n个具有相同元组数目的桶 

```sql
select ID, ntile(4) over (order by GPA desc) as quartile
from student_grades;
```



#### 高级聚集-分窗

窗口查询用来对于一定范围内的元组计算聚集函数



between rows unbounded preceding and current第一行至当前行的汇总

rows unbounded preceding当前行前面的记录

range  between 10 preceding and current row当前行的前10行

range interval 10 day preceding不包括当前行



可以在分区内分窗

```sql
一个关系transaction (account_number, date_time, value)，存款的话值为正，提款的话值为负
求出每个账户上的交易完成后，每个账户的余额
select account_number, date_time,
sum (value) over
(partition by account_number 
 order by date_time
 rows unbounded preceding)
 as balance
 from transaction
 order by account_number, date_time
```

